{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch31505\stshfloch31506\stshfhich31506\stshfbi31507\deflang1033\deflangfe1033\themelang1033\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fbidi \fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f34\fbidi \froman\fcharset1\fprq2{\*\panose 02040503050406030204}Cambria Math;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f39\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f40\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f42\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f43\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f44\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f45\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f46\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f47\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f59\fbidi \fmodern\fcharset238\fprq1 Courier New CE;}{\f60\fbidi \fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f62\fbidi \fmodern\fcharset161\fprq1 Courier New Greek;}{\f63\fbidi \fmodern\fcharset162\fprq1 Courier New Tur;}{\f64\fbidi \fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f65\fbidi \fmodern\fcharset178\fprq1 Courier New (Arabic);}
{\f66\fbidi \fmodern\fcharset186\fprq1 Courier New Baltic;}{\f67\fbidi \fmodern\fcharset163\fprq1 Courier New (Vietnamese);}{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fhimajor\f31528\fbidi \froman\fcharset238\fprq2 Cambria CE;}{\fhimajor\f31529\fbidi \froman\fcharset204\fprq2 Cambria Cyr;}{\fhimajor\f31531\fbidi \froman\fcharset161\fprq2 Cambria Greek;}{\fhimajor\f31532\fbidi \froman\fcharset162\fprq2 Cambria Tur;}
{\fhimajor\f31535\fbidi \froman\fcharset186\fprq2 Cambria Baltic;}{\fhimajor\f31536\fbidi \froman\fcharset163\fprq2 Cambria (Vietnamese);}{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}
{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}
{\fhiminor\f31573\fbidi \fswiss\fcharset177\fprq2 Calibri (Hebrew);}{\fhiminor\f31574\fbidi \fswiss\fcharset178\fprq2 Calibri (Arabic);}{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}
{\fhiminor\f31576\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green176\blue80;}{\*\defchp \fs22\loch\af31506\hich\af31506\dbch\af31505 }{\*\defpap \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }\noqfpromote {\stylesheet{\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 
\ltrch\fcs0 \fs22\lang1033\langfe1033\loch\f31506\hich\af31506\dbch\af31505\cgrid\langnp1033\langfenp1033 \snext0 \sqformat \spriority0 Normal;}{\*\cs10 \additive \ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 \fs22\lang1033\langfe1033\loch\f31506\hich\af31506\dbch\af31505\cgrid\langnp1033\langfenp1033 \snext11 \ssemihidden \sunhideused 
Normal Table;}}{\*\rsidtbl \rsid7492685\rsid8979034\rsid11095480\rsid11298641\rsid12467623}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1\mlMargin0\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info{\operator LENOVO}
{\creatim\yr2022\mo9\dy9\hr18\min44}{\revtim\yr2022\mo9\dy9\hr19\min7}{\version3}{\edmins23}{\nofpages40}{\nofwords11014}{\nofchars62781}{\nofcharsws73648}{\vern49169}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}}
\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\trackmoves0\trackformatting1\donotembedsysfont0\relyonvml0\donotembedlingdata1\grfdocevents0\validatexml0\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors0\horzdoc\dghspace120\dgvspace120\dghorigin1701
\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\rsidroot11298641 \nouicompat \fet0{\*\wgrffmtfilter 2450}\nofeaturethrottle1\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 
\fs22\lang1033\langfe1033\loch\af31506\hich\af31506\dbch\af31505\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 //
\par \hich\af2\dbch\af31505\loch\f2 // Copyright (C) 2014 OpenSim Ltd.
\par \hich\af2\dbch\af31505\loch\f2 //
\par \hich\af2\dbch\af31505\loch\f2 // This program is free software: you can redistribute it and/or modify
\par \hich\af2\dbch\af31505\loch\f2 // it under the terms of the GNU Lesser General Public License as published by
\par \hich\af2\dbch\af31505\loch\f2 // the Free Software Foundation, either version 3 of the License, or
\par \hich\af2\dbch\af31505\loch\f2 // (at your option) any later version.
\par \hich\af2\dbch\af31505\loch\f2 //
\par \hich\af2\dbch\af31505\loch\f2 // This program is distributed in the hope that it will be useful,
\par \hich\af2\dbch\af31505\loch\f2 // but WITHOUT ANY WARRANTY; without even the implied warranty of
\par \hich\af2\dbch\af31505\loch\f2 // MERCHANTA\hich\af2\dbch\af31505\loch\f2 BILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\par \hich\af2\dbch\af31505\loch\f2 // GNU Lesser General Public License for more details.
\par \hich\af2\dbch\af31505\loch\f2 //
\par \hich\af2\dbch\af31505\loch\f2 // You should have received a copy of the GNU Lesser General Public License
\par \hich\af2\dbch\af31505\loch\f2 // along with this program.  If not, see http://www.gnu.org/licenses/.
\par \hich\af2\dbch\af31505\loch\f2 //
\par 
\par \hich\af2\dbch\af31505\loch\f2 #include "AODVRouting.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "IPv4Route.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "Ieee80211Frame_m.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "InterfaceTableAccess.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "IPSocket.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "IPv4ControlInfo.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "UDPControlInfo.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "ModuleAccess.h"
\par \hich\af2\dbch\af31505\loch\f2 #include "NodeOperations.h"
\par \hich\af2\dbch\af31505\loch\f2 #incl\hich\af2\dbch\af31505\loch\f2 ude "RoutingTableAccess.h"
\par 
\par \hich\af2\dbch\af31505\loch\f2 Define_Module(AODVRouting);
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::initialize(int stage)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     if (stage == 0) \{
\par \hich\af2\dbch\af31505\loch\f2         lastBroadcastTime = SIMTIME_ZERO;
\par \hich\af2\dbch\af31505\loch\f2         rebootTime = SIMTIME_ZERO;
\par \hich\af2\dbch\af31505\loch\f2         rreqId = sequenceNum = 0;
\par \hich\af2\dbch\af31505\loch\f2         rreqCount = rerrCount = 0;
\par \hich\af2\dbch\af31505\loch\f2         host = getContainingNode(this);
\par \hich\af2\dbch\af31505\loch\f2         routingTable = RoutingTableAccess().get();
\par \hich\af2\dbch\af31505\loch\f2         interfaceTable = InterfaceTableAccess().get();
\par \hich\af2\dbch\af31505\loch\f2         networkProtocol = check_and_cast<INetfilter *>(getModuleByPath(par(\hich\af2\dbch\af31505\loch\f2 "networkProtocolModule")));
\par 
\par \hich\af2\dbch\af31505\loch\f2         aodvUDPPort = par("udpPort");
\par \hich\af2\dbch\af31505\loch\f2         askGratuitousRREP = par("askGratuitousRREP");
\par \hich\af2\dbch\af31505\loch\f2         useHelloMessages = par("useHelloMessages");
\par \hich\af2\dbch\af31505\loch\f2         activeRouteTimeout = par("activeRouteTimeout");
\par \hich\af2\dbch\af31505\loch\f2         helloInterval = par\hich\af2\dbch\af31505\loch\f2 ("helloInterval");
\par \hich\af2\dbch\af31505\loch\f2         allowedHelloLoss = par("allowedHelloLoss");
\par \hich\af2\dbch\af31505\loch\f2         netDiameter = par("netDiameter");
\par \hich\af2\dbch\af31505\loch\f2         nodeTraversalTime = par("nodeTraversalTime");
\par \hich\af2\dbch\af31505\loch\f2         rerrRatelimit = par("rerrRatelimit");
\par \hich\af2\dbch\af31505\loch\f2         rreqRetries = par("rreqRetries");
\par \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2        rreqRatelimit = par("rreqRatelimit");
\par \hich\af2\dbch\af31505\loch\f2         timeoutBuffer = par("timeoutBuffer");
\par \hich\af2\dbch\af31505\loch\f2         ttlStart = par("ttlStart");
\par \hich\af2\dbch\af31505\loch\f2         ttlIncrement = par("ttlIncrement");
\par \hich\af2\dbch\af31505\loch\f2         ttlThreshold = par("ttlThreshold");
\par \hich\af2\dbch\af31505\loch\f2         localAddTTL = par("localAddTTL");
\par \hich\af2\dbch\af31505\loch\f2         jitterPar = &par("jitter");
\par \hich\af2\dbch\af31505\loch\f2         periodicJitter = &par("periodicJitter");
\par 
\par \hich\af2\dbch\af31505\loch\f2         myRouteTimeout = par("myRouteTimeout");
\par \hich\af2\dbch\af31505\loch\f2         deletePeriod = par("deletePeriod");
\par \hich\af2\dbch\af31505\loch\f2         blacklistTimeout = par("blacklistTimeout");
\par \hich\af2\dbch\af31505\loch\f2         netTraversalTime \hich\af2\dbch\af31505\loch\f2 = par("netTraversalTime");
\par \hich\af2\dbch\af31505\loch\f2         nextHopWait = par("nextHopWait");
\par \hich\af2\dbch\af31505\loch\f2         pathDiscoveryTime = par("pathDiscoveryTime");
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else if (stage == 4) \{
\par \hich\af2\dbch\af31505\loch\f2         NodeStatus *nodeStatus = dynamic_cast<NodeStatus *>(host->getSubmodule("status"));
\par \hich\af2\dbch\af31505\loch\f2         i\hich\af2\dbch\af31505\loch\f2 sOperational = !nodeStatus || nodeStatus->getState() == NodeStatus::UP;
\par 
\par \hich\af2\dbch\af31505\loch\f2         IPSocket socket(gate("ipOut"));
\par \hich\af2\dbch\af31505\loch\f2         socket.registerProtocol(IP_PROT_MANET);
\par \hich\af2\dbch\af31505\loch\f2         networkProtocol->registerHook(0, this);
\par \hich\af2\dbch\af31505\loch\f2         nb = NotificationBoardAccess().get();
\par \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2        nb->subscribe(this, NF_LINK_BREAK);
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (useHelloMessages) \{
\par \hich\af2\dbch\af31505\loch\f2             helloMsgTimer = new cMessage("HelloMsgTimer");
\par 
\par \hich\af2\dbch\af31505\loch\f2             // RFC 5148:
\par \hich\af2\dbch\af31505\loch\f2             // Jitter SHOULD be applied by reducing this delay by a random amount, so that
\par \hich\af2\dbch\af31505\loch\f2     \hich\af2\dbch\af31505\loch\f2         // the delay between consecutive transmissions of messages of the same type is
\par \hich\af2\dbch\af31505\loch\f2             // equal to (MESSAGE_INTERVAL - jitter), where jitter is the random value.
\par \hich\af2\dbch\af31505\loch\f2             if (isOperational)
\par \hich\af2\dbch\af31505\loch\f2                 scheduleAt(simTi\hich\af2\dbch\af31505\loch\f2 me() + helloInterval - periodicJitter->doubleValue(), helloMsgTimer);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par 
\par \hich\af2\dbch\af31505\loch\f2         expungeTimer = new cMessage("ExpungeTimer");
\par \hich\af2\dbch\af31505\loch\f2         counterTimer = new cMessage("CounterTimer");
\par \hich\af2\dbch\af31505\loch\f2         rrepAckTimer = new cMessage("RREPACKTimer");
\par \hich\af2\dbch\af31505\loch\f2         blacklis\hich\af2\dbch\af31505\loch\f2 tTimer = new cMessage("BlackListTimer");
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (isOperational)
\par \hich\af2\dbch\af31505\loch\f2             scheduleAt(simTime() + 1, counterTimer);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleMessage(cMessage *msg)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     if (!isOperational) \{
\par \hich\af2\dbch\af31505\loch\f2         if (msg->isSelfMessage())
\par \hich\af2\dbch\af31505\loch\f2             thro\hich\af2\dbch\af31505\loch\f2 w cRuntimeError("Model error: self msg '%s' received when isOperational is false", msg->getName());
\par 
\par \hich\af2\dbch\af31505\loch\f2         EV_ERROR << "Application is turned off, dropping '" << msg->getName() << "' message\\n";
\par \hich\af2\dbch\af31505\loch\f2         delete msg;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (msg->isSelfMessage()) \{
\par \hich\af2\dbch\af31505\loch\f2         if (dynamic_cast<WaitForRREP *>(msg))
\par \hich\af2\dbch\af31505\loch\f2             handleWaitForRREP((WaitForRREP *)msg);
\par \hich\af2\dbch\af31505\loch\f2         else if (msg == helloMsgTimer)
\par \hich\af2\dbch\af31505\loch\f2             sendHelloMessagesIfNeeded();
\par \hich\af2\dbch\af31505\loch\f2         else if (msg == expungeTimer)
\par \hich\af2\dbch\af31505\loch\f2             expungeRoutes();
\par \hich\af2\dbch\af31505\loch\f2         else if (msg == counterTimer) \{
\par \hich\af2\dbch\af31505\loch\f2             rreqCount = rerrCount = 0;
\par \hich\af2\dbch\af31505\loch\f2             scheduleAt(simTime() + 1, counterTimer);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else if (msg == rrepAckTimer)
\par \hich\af2\dbch\af31505\loch\f2             handleRREPACKTimer();
\par \hich\af2\dbch\af31505\loch\f2         else if (msg == blacklistTimer)
\par \hich\af2\dbch\af31505\loch\f2   \hich\af2\dbch\af31505\loch\f2           handleBlackListTimer();
\par \hich\af2\dbch\af31505\loch\f2         else
\par \hich\af2\dbch\af31505\loch\f2             throw cRuntimeError("Unknown self message");
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         UDPPacket *udpPacket = dynamic_cast<UDPPacket *>(msg);
\par \hich\af2\dbch\af31505\loch\f2         AODVControlPacket *ctrlPacket = check_and_cast<AODVControlPacket\hich\af2\dbch\af31505\loch\f2  *>(udpPacket->decapsulate());
\par \hich\af2\dbch\af31505\loch\f2         IPv4ControlInfo *udpProtocolCtrlInfo = dynamic_cast<IPv4ControlInfo *>(udpPacket->getControlInfo());
\par \hich\af2\dbch\af31505\loch\f2         ASSERT(udpProtocolCtrlInfo != NULL);
\par \hich\af2\dbch\af31505\loch\f2         IPv4Address sourceAddr = udpProtocolCtrlInfo->getSrcAddr();
\par \hich\af2\dbch\af31505\loch\f2    \hich\af2\dbch\af31505\loch\f2      unsigned int arrivalPacketTTL = udpProtocolCtrlInfo->getTimeToLive();
\par 
\par \hich\af2\dbch\af31505\loch\f2         switch (ctrlPacket->getPacketType()) \{
\par \hich\af2\dbch\af31505\loch\f2             case RREQ:
\par \hich\af2\dbch\af31505\loch\f2                 handleRREQ(check_and_cast<AODVRREQ *>(ctrlPacket), sourceAddr, arrivalPacketTTL);
\par \hich\af2\dbch\af31505\loch\f2             \hich\af2\dbch\af31505\loch\f2     break;
\par 
\par \hich\af2\dbch\af31505\loch\f2             case RREP:
\par \hich\af2\dbch\af31505\loch\f2                 handleRREP(check_and_cast<AODVRREP *>(ctrlPacket), sourceAddr);
\par \hich\af2\dbch\af31505\loch\f2                 break;
\par 
\par \hich\af2\dbch\af31505\loch\f2             case RERR:
\par \hich\af2\dbch\af31505\loch\f2                 handleRERR(check_and_cast<AODVRERR *>(ctrlPacket), sourceAddr);
\par \hich\af2\dbch\af31505\loch\f2                 break;
\par 
\par \hich\af2\dbch\af31505\loch\f2             case RREPACK:
\par \hich\af2\dbch\af31505\loch\f2                 handleRREPACK(check_and_cast<AODVRREPACK *>(ctrlPacket), sourceAddr);
\par \hich\af2\dbch\af31505\loch\f2                 break;
\par 
\par \hich\af2\dbch\af31505\loch\f2             default:
\par \hich\af2\dbch\af31505\loch\f2                 throw cRuntimeError("AODV Control Packet arrived with undef\hich\af2\dbch\af31505\loch\f2 ined packet type: %d", ctrlPacket->getPacketType());
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         delete udpPacket;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 INetfilter::IHook::Result AODVRouting::ensureRouteForDatagram(IPv4Datagram *datagram)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     Enter_Method("datagramPreRoutingHook");
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& des\hich\af2\dbch\af31505\loch\f2 tAddr = datagram->getDestAddress();
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& sourceAddr = datagram->getSrcAddress();
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11298641 
\par \hich\af2\dbch\af31505\loch\f2 /*
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid11298641 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 Each time a route is used to forward }{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 a data packet, its Active Route. }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 Lifetime field of the source, dest}{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 ination and the next hop on the }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 path to the destination is updated t\hich\af2\dbch\af31505\loch\f2 
o be no less than the current}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 time plus ACTIVE_ROUTE_TIMEOUT.}{\rtlch\fcs1 \af2 
\ltrch\fcs0 \f2\cf17\insrsid11298641 
\par \hich\af2\dbch\af31505\loch\f2 */
\par \hich\af2\dbch\af31505\loch\f2 // \hich\af2\dbch\af31505\loch\f2 Check the limited broadband address while sending the route request. 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11298641 \hich\af2\dbch\af31505\loch\f2  
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 if (destAddr.isLimitedBroadcastAddress() || routingTable->isLocalAddress(destAddr) || destAddr.isMulticast())
\par \hich\af2\dbch\af31505\loch\f2         return ACCEPT;
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "Finding route for source " << sourceAddr << " with destination " << destAddr << endl;
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->findBestMatchingRoute(destAddr);
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = route ? dynamic_cast<AODVRouteData *>(route->getProtocolData()) : NULL;
\par \hich\af2\dbch\af31505\loch\f2         bool isActive = routeData && routeData->isActive();
\par \hich\af2\dbch\af31505\loch\f2         if (isActive && !route->getGateway().isUnspecified()) \{
\par \hich\af2\dbch\af31505\loch\f2             EV_INFO << "A\hich\af2\dbch\af31505\loch\f2 ctive route found: " << route << endl;
\par 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid11298641 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2             
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2             updateValidRouteLifeTime(destAddr, simTime() + activeRouteTimeout);
\par \hich\af2\dbch\af31505\loch\f2             updateValidRouteLifeTime(route->getGateway(), simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2       \hich\af2\dbch\af31505\loch\f2       return ACCEPT;
\par \hich\af2\dbch\af31505\loch\f2         \}
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2         }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 
else if (sourceAddr.isUnspecified() || routingTable->isLocalAddress(sourceAddr)) \{
\par \hich\af2\dbch\af31505\loch\f2             bool isInactive = routeData && !routeData->isActive();
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // A node disseminates a RREQ when it determines that i}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 t needs a route }{
\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 to a destination and does not have one}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2  available.  This can happen if }{\rtlch\fcs1 
\af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 the destination is previously unknown }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 to the node, or if a previously }{\rtlch\fcs1 \af2 
\ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 valid route to the destination }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 expire}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\hich\af2\dbch\af31505\loch\f2  or is marked as \hich\af2\dbch\af31505\loch\f2 invalid.
\par 
\par \hich\af2\dbch\af31505\loch\f2             EV_INFO << (isInactive ? "Inactive" : "Missing") << " route for destination " << destAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2             delayDatagram(datagram);
\par 
\par \hich\af2\dbch\af31505\loch\f2             if (!hasOngoingRouteDiscovery(destAddr)) \{
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // When a new route to the same destinat}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 ion is required at a later time }{
\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 (e.g., upon route loss), the TTL in }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 \hich\af2\dbch\af31505\loch\f2 the RREQ IP header is initially }{\rtlch\fcs1 
\af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 set to the Hop Count plus TTL_INCREMENT.
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11298641 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2                 if (i\hich\af2\dbch\af31505\loch\f2 sInactive)
\par \hich\af2\dbch\af31505\loch\f2                     startRouteDiscovery(destAddr, route->getMetric() + ttlIncrement);
\par \hich\af2\dbch\af31505\loch\f2                 else
\par \hich\af2\dbch\af31505\loch\f2                     startRouteDiscovery(destAddr);
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2             else
\par \hich\af2\dbch\af31505\loch\f2                 EV_DETAIL << "Route discovery is in prog\hich\af2\dbch\af31505\loch\f2 ress, originator " << getSelfIPAddress() << " target " << destAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2             return QUEUE;
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else
\par \hich\af2\dbch\af31505\loch\f2             return ACCEPT;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 AODVRouting::AODVRouting()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     interfaceTable = NULL;
\par \hich\af2\dbch\af31505\loch\f2     host = NULL;
\par \hich\af2\dbch\af31505\loch\f2     routingTable = NU\hich\af2\dbch\af31505\loch\f2 LL;
\par \hich\af2\dbch\af31505\loch\f2     isOperational = false;
\par \hich\af2\dbch\af31505\loch\f2     networkProtocol = NULL;
\par \hich\af2\dbch\af31505\loch\f2     helloMsgTimer = NULL;
\par \hich\af2\dbch\af31505\loch\f2     expungeTimer = NULL;
\par \hich\af2\dbch\af31505\loch\f2     blacklistTimer = NULL;
\par \hich\af2\dbch\af31505\loch\f2     rrepAckTimer = NULL;
\par \hich\af2\dbch\af31505\loch\f2     jitterPar = NULL;
\par \hich\af2\dbch\af31505\loch\f2     nb = NULL;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 bool AODVRouting::hasOngoingRouteDiscovery(const IPv4Address& target)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     return waitForRREPTimers.find(target) != waitForRREPTimers.end();
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::startRouteDiscovery(const IPv4Address& target, unsigned timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Startin\hich\af2\dbch\af31505\loch\f2 g route discovery with originator " << getSelfIPAddress() << " and destination " << target << endl;
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(!hasOngoingRouteDiscovery(target));
\par \hich\af2\dbch\af31505\loch\f2     AODVRREQ *rreq = createRREQ(target);
\par \hich\af2\dbch\af31505\loch\f2     addressToRreqRetries[target] = 0;
\par \hich\af2\dbch\af31505\loch\f2     sendRREQ(rreq, IPv4Address\hich\af2\dbch\af31505\loch\f2 ::ALLONES_ADDRESS, timeToLive);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 IPv4Address AODVRouting::getSelfIPAddress() const
\par \{
\par \hich\af2\dbch\af31505\loch\f2     return routingTable->getRouterId();
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::delayDatagram(IPv4Datagram *datagram)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_DETAIL << "Queuing datagram, source " << datagram->getSrcAddr\hich\af2\dbch\af31505\loch\f2 ess() << ", destination " << datagram->getDestAddress() << endl;
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& target = datagram->getDestAddress();
\par \hich\af2\dbch\af31505\loch\f2     targetAddressToDelayedPackets.insert(std::pair<IPv4Address, IPv4Datagram *>(target, datagram));
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendRREQ(AODVRREQ *rreq, const IPv4Address& destAddr, unsigned int timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // In an expanding ring search, the originating node initially uses a TTL =
\par \hich\af2\dbch\af31505\loch\f2     // TTL_START in the RREQ packet IP header and sets the timeout for
\par \hich\af2\dbch\af31505\loch\f2     //\hich\af2\dbch\af31505\loch\f2  receiving a RREP to RING_TRAVERSAL_TIME milliseconds.
\par \hich\af2\dbch\af31505\loch\f2     // RING_TRAVERSAL_TIME is calculated as described in section 10.  The
\par \hich\af2\dbch\af31505\loch\f2     // TTL_VALUE used in calculating RING_TRAVERSAL_TIME is set equal to the
\par \hich\af2\dbch\af31505\loch\f2     // value of the TTL field in the IP header.  I\hich\af2\dbch\af31505\loch\f2 f the RREQ times out
\par \hich\af2\dbch\af31505\loch\f2     // without a corresponding RREP, the originator broadcasts the RREQ
\par \hich\af2\dbch\af31505\loch\f2     // again with the TTL incremented by TTL_INCREMENT.  This continues
\par \hich\af2\dbch\af31505\loch\f2     // until the TTL set in the RREQ reaches TTL_THRESHOLD, beyond which a
\par \hich\af2\dbch\af31505\loch\f2     // TTL = NET\hich\af2\dbch\af31505\loch\f2 _DIAMETER is used for each attempt.
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid12467623 
\par \hich\af2\dbch\af31505\loch\f2 // Check the route request limit. }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid12467623 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     if (rreqCount >= rreqRatelimit) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "A node should not originate more than RREQ_RATELIMIT RREQ messages per second. Canceling sending RREQ" << endl;
\par \hich\af2\dbch\af31505\loch\f2         delete rreq;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     s\hich\af2\dbch\af31505\loch\f2 td::map<IPv4Address, WaitForRREP *>::iterator rrepTimer = waitForRREPTimers.find(rreq->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     WaitForRREP *rrepTimerMsg = NULL;
\par \hich\af2\dbch\af31505\loch\f2     if (rrepTimer != waitForRREPTimers.end()) \{
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg = rrepTimer->second;
\par \hich\af2\dbch\af31505\loch\f2         unsigned int last\hich\af2\dbch\af31505\loch\f2 TTL = rrepTimerMsg->getLastTTL();
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg->setDestAddr(rreq->getDestAddr());
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The Hop Count stored in an invalid routing table entry indicates the
\par \hich\af2\dbch\af31505\loch\f2         // last known hop count to that destination in the routing table.  When
\par \hich\af2\dbch\af31505\loch\f2         // a new route to the same destination is required at a later time
\par \hich\af2\dbch\af31505\loch\f2         // (e.g., upon route loss), the TTL in the RREQ IP header is initially
\par \hich\af2\dbch\af31505\loch\f2         // set to the Hop Count plus TTL_INCREMENT.  Thereafter, following each
\par \hich\af2\dbch\af31505\loch\f2         // timeout the\hich\af2\dbch\af31505\loch\f2  TTL is incremented by TTL_INCREMENT until TTL =
\par \hich\af2\dbch\af31505\loch\f2         // TTL_THRESHOLD is reached.  Beyond this TTL = NET_DIAMETER is used.
\par \hich\af2\dbch\af31505\loch\f2         // Once TTL = NET_DIAMETER, the timeout for waiting for the RREP is set
\par \hich\af2\dbch\af31505\loch\f2         // to NET_TRAVERSAL_TIME, as specified in\hich\af2\dbch\af31505\loch\f2  section 6.3.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (timeToLive != 0) \{
\par \hich\af2\dbch\af31505\loch\f2             rrepTimerMsg->setLastTTL(timeToLive);
\par \hich\af2\dbch\af31505\loch\f2             rrepTimerMsg->setFromInvalidEntry(true);
\par \hich\af2\dbch\af31505\loch\f2             cancelEvent(rrepTimerMsg);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else if (lastTTL + ttlIncrement < ttlThreshold) \{
\par \hich\af2\dbch\af31505\loch\f2             ASSERT(!rrepTimerMsg->isScheduled());
\par \hich\af2\dbch\af31505\loch\f2             timeToLive = lastTTL + ttlIncrement;
\par \hich\af2\dbch\af31505\loch\f2             rrepTimerMsg->setLastTTL(lastTTL + ttlIncrement);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else \{
\par \hich\af2\dbch\af31505\loch\f2             ASSERT(!rrepTimerMsg->isScheduled());
\par \hich\af2\dbch\af31505\loch\f2             timeToLi\hich\af2\dbch\af31505\loch\f2 ve = netDiameter;
\par \hich\af2\dbch\af31505\loch\f2             rrepTimerMsg->setLastTTL(netDiameter);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg = new WaitForRREP();
\par \hich\af2\dbch\af31505\loch\f2         waitForRREPTimers[rreq->getDestAddr()] = rrepTimerMsg;
\par \hich\af2\dbch\af31505\loch\f2         ASSERT(hasOngoingRouteDiscovery(rreq->getDestAddr()));
\par 
\par \hich\af2\dbch\af31505\loch\f2         timeToLive = ttlStart;
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg->setLastTTL(ttlStart);
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg->setFromInvalidEntry(false);
\par \hich\af2\dbch\af31505\loch\f2         rrepTimerMsg->setDestAddr(rreq->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     \}}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid12467623 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // Each time, the timeout for receiving a RREP is RING_TRAVERSAL_TIME.
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid12467623 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     simtime_t ringTraversalTime = 2.0 * nodeTraversalTime * (timeToLive + timeoutBuffer);
\par \hich\af2\dbch\af31505\loch\f2     scheduleAt(simTime() + ringTraversalTime, rrepTimerMsg);}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par 
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Sending a Route R\hich\af2\dbch\af31505\loch\f2 equest with target " << rreq->getDestAddr() << " and TTL= " << timeToLive << endl;
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rreq, destAddr, timeToLive, jitterPar->doubleValue());
\par \hich\af2\dbch\af31505\loch\f2     rreqCount++;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendRREP(AODVRREP *rrep, const IPv4Address& destAddr, unsigne\hich\af2\dbch\af31505\loch\f2 d int timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Sending Route Reply to " << destAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // When any node transmits a RREP, the precursor list for the
\par \hich\af2\dbch\af31505\loch\f2     // corresponding destination node is updated by adding to it
\par \hich\af2\dbch\af31505\loch\f2     // the next hop node to which the RREP\hich\af2\dbch\af31505\loch\f2  is forwarded.
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *destRoute = routingTable->findBestMatchingRoute(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& nextHop = destRoute->getGateway();
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *destRouteData = check_and_cast<AODVRouteData *>(destRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2     destRouteData->addPrecursor(nextHop);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // The node we received the Route Request for is our neighbor,
\par \hich\af2\dbch\af31505\loch\f2     // it is probably an unidirectional link
\par \hich\af2\dbch\af31505\loch\f2     if (destRoute->getMetric() == 1) \{
\par \hich\af2\dbch\af31505\loch\f2         // It is possible that a RREP transmission may fail, e\hich\af2\dbch\af31505\loch\f2 specially if the
\par \hich\af2\dbch\af31505\loch\f2         // RREQ transmission triggering the RREP occurs over a unidirectional
\par \hich\af2\dbch\af31505\loch\f2         // link.
\par 
\par \hich\af2\dbch\af31505\loch\f2         rrep->setAckRequiredFlag(true);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // when a node detects that its transmission of a RREP message has failed,
\par \hich\af2\dbch\af31505\loch\f2         // it remem\hich\af2\dbch\af31505\loch\f2 bers the next-hop of the failed RREP in a "blacklist" set.
\par 
\par \hich\af2\dbch\af31505\loch\f2         failedNextHop = nextHop;
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (rrepAckTimer->isScheduled())
\par \hich\af2\dbch\af31505\loch\f2             cancelEvent(rrepAckTimer);
\par 
\par \hich\af2\dbch\af31505\loch\f2         scheduleAt(simTime() + nextHopWait, rrepAckTimer);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPack\hich\af2\dbch\af31505\loch\f2 et(rrep, nextHop, timeToLive, 0);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRREQ *AODVRouting::createRREQ(const IPv4Address& destAddr)
\par \{
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid12467623 \hich\af2\dbch\af31505\loch\f2 //Before sending the route request\hich\af2\dbch\af31505\loch\f2 , first check the routing table to find the route to the destination node. }{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\cf17\insrsid12467623 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     AODVRREQ *rreqPacket = new AODVRREQ("AODV-RREQ");
\par 
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setGratuitousRREPFlag(askGratuitousRREP);
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *lastKnownRoute = routingTable->findBestMatchingRoute(destAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setPacketType(RREQ);
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     // The Originator Sequence Number in the RREQ message is the
\par \hich\af2\dbch\af31505\loch\f2     // node's own sequence number, which is incremented prior to
\par \hich\af2\dbch\af31505\loch\f2     // i\hich\af2\dbch\af31505\loch\f2 nsertion in a RREQ.
\par \hich\af2\dbch\af31505\loch\f2     sequenceNum++;
\par 
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setOriginatorSeqNum(sequenceNum);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (lastKnownRoute && lastKnownRoute->getSource() == this) \{
\par \hich\af2\dbch\af31505\loch\f2         // The Destination Sequence Number field in the RREQ message is the last
\par \hich\af2\dbch\af31505\loch\f2         // known de\hich\af2\dbch\af31505\loch\f2 stination sequence number for this destination and is copied
\par \hich\af2\dbch\af31505\loch\f2         // from the Destination Sequence Number field in the routing table.
\par 
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = check_and_cast<AODVRouteData *>(lastKnownRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         if (rou\hich\af2\dbch\af31505\loch\f2 teData && routeData->hasValidDestNum()) \{
\par \hich\af2\dbch\af31505\loch\f2             rreqPacket->setDestSeqNum(routeData->getDestSeqNum());
\par \hich\af2\dbch\af31505\loch\f2             rreqPacket->setUnknownSeqNumFlag(false);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else
\par \hich\af2\dbch\af31505\loch\f2             rreqPacket->setUnknownSeqNumFlag(true);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         rreqPacket->setUnknownSeqNumFlag(true); // If no sequence number is known, the unknown sequence number flag MUST be set.
\par 
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setOriginatorAddr(getSelfIPAddress());
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setDestAddr(destAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // The RREQ ID field is inc\hich\af2\dbch\af31505\loch\f2 remented by one from the last RREQ ID used
\par \hich\af2\dbch\af31505\loch\f2     // by the current node. Each node maintains only one RREQ ID.
\par \hich\af2\dbch\af31505\loch\f2     rreqId++;
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setRreqId(rreqId);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // The Hop Count field is set to zero.
\par \hich\af2\dbch\af31505\loch\f2     rreqPacket->setHopCount(0);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Before broadca\hich\af2\dbch\af31505\loch\f2 sting the RREQ, the originating node buffers the RREQ
\par \hich\af2\dbch\af31505\loch\f2     // ID and the Originator IP address (its own address) of the RREQ for
\par \hich\af2\dbch\af31505\loch\f2     // PATH_DISCOVERY_TIME.
\par \hich\af2\dbch\af31505\loch\f2     // In this way, when the node receives the packet again from its neighbors,
\par \hich\af2\dbch\af31505\loch\f2     // it will not r\hich\af2\dbch\af31505\loch\f2 eprocess and re-forward the packet.
\par 
\par \hich\af2\dbch\af31505\loch\f2     RREQIdentifier rreqIdentifier(getSelfIPAddress(), rreqId);
\par \hich\af2\dbch\af31505\loch\f2     rreqsArrivalTime[rreqIdentifier] = simTime();
\par 
\par \hich\af2\dbch\af31505\loch\f2     return rreqPacket;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRREP *AODVRouting::createRREP(AODVRREQ *rreq, IPv4Route *destRoute, IPv4Rou\hich\af2\dbch\af31505\loch\f2 te *originatorRoute, const IPv4Address& lastHopAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     AODVRREP *rrep = new AODVRREP("AODV-RREP");
\par \hich\af2\dbch\af31505\loch\f2     rrep->setPacketType(RREP);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // When generating a RREP message, a node copies the Destination IP
\par \hich\af2\dbch\af31505\loch\f2     // IPv4Address and the Originator Sequence Number from the RREQ message into
\par \hich\af2\dbch\af31505\loch\f2     // the corresponding fields in the RREP message.
\par 
\par \hich\af2\dbch\af31505\loch\f2     rrep->setDestAddr(rreq->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     rrep->setOriginatorSeqNum(rreq->getOriginatorSeqNum());
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Originato\hich\af2\dbch\af31505\loch\f2 rAddr = The IP address of the node which originated the RREQ
\par \hich\af2\dbch\af31505\loch\f2     // for which the route is supplied.
\par \hich\af2\dbch\af31505\loch\f2     rrep->setOriginatorAddr(rreq->getOriginatorAddr());
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Processing is slightly different, depending on whether the node is
\par \hich\af2\dbch\af31505\loch\f2     // itself the reques\hich\af2\dbch\af31505\loch\f2 ted destination (see section 6.6.1), or instead
\par \hich\af2\dbch\af31505\loch\f2     // if it is an intermediate node with an fresh enough route to the destination
\par \hich\af2\dbch\af31505\loch\f2     // (see section 6.6.2).
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (rreq->getDestAddr() == getSelfIPAddress()) \{    // node is itself the requested destinat\hich\af2\dbch\af31505\loch\f2 ion
\par \hich\af2\dbch\af31505\loch\f2         // If the generating node is the destination itself, it MUST increment
\par \hich\af2\dbch\af31505\loch\f2         // its own sequence number by one if the sequence number in the RREQ
\par \hich\af2\dbch\af31505\loch\f2         // packet is equal to that incremented value.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (!rreq->getUnknownSeqNumFlag()\hich\af2\dbch\af31505\loch\f2  && sequenceNum + 1 == rreq->getDestSeqNum())
\par \hich\af2\dbch\af31505\loch\f2             sequenceNum++;
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The destination node places its (perhaps newly incremented)
\par \hich\af2\dbch\af31505\loch\f2         // sequence number into the Destination Sequence Number field of
\par \hich\af2\dbch\af31505\loch\f2         // the RREP,
\par \hich\af2\dbch\af31505\loch\f2         rrep->setDestSeqNum(sequenceNum);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // and enters the value zero in the Hop Count field
\par \hich\af2\dbch\af31505\loch\f2         // of the RREP.
\par \hich\af2\dbch\af31505\loch\f2         rrep->setHopCount(0);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The destination node copies the value MY_ROUTE_TIMEOUT
\par \hich\af2\dbch\af31505\loch\f2         // into the Lifetime fie\hich\af2\dbch\af31505\loch\f2 ld of the RREP.
\par \hich\af2\dbch\af31505\loch\f2         rrep->setLifeTime(myRouteTimeout);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{    // intermediate node
\par \hich\af2\dbch\af31505\loch\f2               // it copies its known sequence number for the destination into
\par \hich\af2\dbch\af31505\loch\f2               // the Destination Sequence Number field in the RREP message.
\par \hich\af2\dbch\af31505\loch\f2   \hich\af2\dbch\af31505\loch\f2       AODVRouteData *destRouteData = check_and_cast<AODVRouteData *>(destRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *originatorRouteData = check_and_cast<AODVRouteData *>(originatorRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         rrep->setDestSeqNum(destRouteData-\hich\af2\dbch\af31505\loch\f2 >getDestSeqNum());
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The intermediate node updates the forward route entry by placing the
\par \hich\af2\dbch\af31505\loch\f2         // last hop node (from which it received the RREQ, as indicated by the
\par \hich\af2\dbch\af31505\loch\f2         // source IP address field in the IP header) into the precursor list \hich\af2\dbch\af31505\loch\f2 for
\par \hich\af2\dbch\af31505\loch\f2         // the forward route entry -- i.e., the entry for the Destination IP
\par \hich\af2\dbch\af31505\loch\f2         // IPv4Address.
\par \hich\af2\dbch\af31505\loch\f2         destRouteData->addPrecursor(lastHopAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The intermediate node also updates its route table entry
\par \hich\af2\dbch\af31505\loch\f2         // for the node originat\hich\af2\dbch\af31505\loch\f2 ing the RREQ by placing the next hop towards the
\par \hich\af2\dbch\af31505\loch\f2         // destination in the precursor list for the reverse route entry --
\par \hich\af2\dbch\af31505\loch\f2         // i.e., the entry for the Originator IP IPv4Address field of the RREQ
\par \hich\af2\dbch\af31505\loch\f2         // message data.
\par 
\par \hich\af2\dbch\af31505\loch\f2         originatorRouteData->addPrecursor(destRoute->getGateway());
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The intermediate node places its distance in hops from the
\par \hich\af2\dbch\af31505\loch\f2         // destination (indicated by the hop count in the routing table)
\par \hich\af2\dbch\af31505\loch\f2         // Hop Count field in the RREP.
\par 
\par \hich\af2\dbch\af31505\loch\f2    \hich\af2\dbch\af31505\loch\f2      rrep->setHopCount(destRoute->getMetric());
\par 
\par \hich\af2\dbch\af31505\loch\f2         // The Lifetime field of the RREP is calculated by subtracting the
\par \hich\af2\dbch\af31505\loch\f2         // current time from the expiration time in its route table entry.
\par 
\par \hich\af2\dbch\af31505\loch\f2         rrep->setLifeTime(destRouteData->getLifeTime() -\hich\af2\dbch\af31505\loch\f2  simTime());
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     return rrep;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRREP *AODVRouting::createGratuitousRREP(AODVRREQ *rreq, IPv4Route *originatorRoute)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(originatorRoute != NULL);
\par \hich\af2\dbch\af31505\loch\f2     AODVRREP *grrep = new AODVRREP("AODV-GRREP");
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *routeData = check_and\hich\af2\dbch\af31505\loch\f2 _cast<AODVRouteData *>(originatorRoute->getProtocolData());
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Hop Count                        The Hop Count as indicated in the
\par \hich\af2\dbch\af31505\loch\f2     //                                  node's route table entry for the
\par \hich\af2\dbch\af31505\loch\f2     //                                  originat\hich\af2\dbch\af31505\loch\f2 or
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // Destination IP IPv4Address           The IP address of the node that
\par \hich\af2\dbch\af31505\loch\f2     //                                  originated the RREQ
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // Destination Sequence Number      The Originator Sequence Number from
\par \hich\af2\dbch\af31505\loch\f2     //                                  the RREQ
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // Originator IP IPv4Address            The IP address of the Destination
\par \hich\af2\dbch\af31505\loch\f2     //                                  node in the RREQ
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // Lifetime                         The remaining life\hich\af2\dbch\af31505\loch\f2 time of the route
\par \hich\af2\dbch\af31505\loch\f2     //                                  towards the originator of the RREQ,
\par \hich\af2\dbch\af31505\loch\f2     //                                  as known by the intermediate node.
\par 
\par \hich\af2\dbch\af31505\loch\f2     grrep->setPacketType(RREP);
\par \hich\af2\dbch\af31505\loch\f2     grrep->setHopCount(originatorRoute->getMetric());
\par \hich\af2\dbch\af31505\loch\f2     grrep->setDestAddr(rreq->getOriginatorAddr());
\par \hich\af2\dbch\af31505\loch\f2     grrep->setDestSeqNum(rreq->getOriginatorSeqNum());
\par \hich\af2\dbch\af31505\loch\f2     grrep->setOriginatorAddr(rreq->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     grrep->setLifeTime(routeData->getLifeTime());
\par 
\par \hich\af2\dbch\af31505\loch\f2     return grrep;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleRRE\hich\af2\dbch\af31505\loch\f2 P(AODVRREP *rrep, const IPv4Address& sourceAddr)
\par \{
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid11095480 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 // When a node receives a RREP message, }{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 first }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 it searches (usi}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 ng
\par \hich\af2\dbch\af31505\loch\f2 // \hich\af2\dbch\af31505\loch\f2 longest-}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 prefix matching) for a route to the previous hop.}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 
\hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 If needed, }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 // }{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 a route is created for the previous hop,}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 
\hich\af2\dbch\af31505\loch\f2 but without a valid sequence }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 //}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 number 
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 
EV_INFO << "AODV Route Reply arrived with source addr: " << sourceAddr << " originator addr: " << rrep->getOriginatorAddr()
\par \hich\af2\dbch\af31505\loch\f2             << " destination addr: " << rrep->getDestAddr() << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (rrep->getOriginatorAddr().isUnspecified()) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "This Route Reply is a Hello Message" << endl;
\par \hich\af2\dbch\af31505\loch\f2         handleHelloMessage(rrep);
\par \hich\af2\dbch\af31505\loch\f2         delete rrep;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid11095480 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *previousHopRoute = routingTable->findBestMatchingR\hich\af2\dbch\af31505\loch\f2 oute(sourceAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (!previousHopRoute || previousHopRoute->getSource() != this) \{
\par \hich\af2\dbch\af31505\loch\f2         // create without valid sequence number
\par \hich\af2\dbch\af31505\loch\f2         previousHopRoute = createRoute(sourceAddr, sourceAddr, 1, false, rrep->getOriginatorSeqNum(), true, simTime() +\hich\af2\dbch\af31505\loch\f2  activeRouteTimeout);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         updateRoutingTable(previousHopRoute, sourceAddr, 1, false, rrep->getOriginatorSeqNum(), true, simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Next, the node then increments the hop count value in the RREP by one,
\par \hich\af2\dbch\af31505\loch\f2     /\hich\af2\dbch\af31505\loch\f2 / to account for the new hop through the intermediate node
\par \hich\af2\dbch\af31505\loch\f2     unsigned int newHopCount = rrep->getHopCount() + 1;
\par \hich\af2\dbch\af31505\loch\f2     rrep->setHopCount(newHopCount);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Then the forward route for this destination is created if it does not
\par \hich\af2\dbch\af31505\loch\f2     // already exist.
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *destRoute = routingTable->findBestMatchingRoute(rrep->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *destRouteData = NULL;
\par \hich\af2\dbch\af31505\loch\f2     simtime_t lifeTime = rrep->getLifeTime();
\par \hich\af2\dbch\af31505\loch\f2     unsigned int destSeqNum = rrep->getDestSeqNum();}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 //Check the routi\hich\af2\dbch\af31505\loch\f2 ng table to find the entry for destination node. }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     if (destRoute && destRoute\hich\af2\dbch\af31505\loch\f2 ->getSource() == this) \{    // already exists
\par \hich\af2\dbch\af31505\loch\f2         destRouteData = check_and_cast<AODVRouteData *>(destRoute->getProtocolData());
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2         // Upon comparison, the existing entry is updated only in the following circumstances:
\par 
\par \hich\af2\dbch\af31505\loch\f2         // (i) the sequence\hich\af2\dbch\af31505\loch\f2  number in the routing table is marked as
\par \hich\af2\dbch\af31505\loch\f2         //     invalid in route table entry.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (!destRouteData->hasValidDestNum()) \{
\par \hich\af2\dbch\af31505\loch\f2             updateRoutingTable(destRoute, sourceAddr, newHopCount, true, destSeqNum, true, simTime() + lifeTime);
\par 
\par \hich\af2\dbch\af31505\loch\f2     \hich\af2\dbch\af31505\loch\f2         // If the route table entry to the destination is created or updated,
\par \hich\af2\dbch\af31505\loch\f2             // then the following actions occur:
\par \hich\af2\dbch\af31505\loch\f2             //
\par \hich\af2\dbch\af31505\loch\f2             // -  the route is marked as active,
\par \hich\af2\dbch\af31505\loch\f2             //
\par \hich\af2\dbch\af31505\loch\f2             // -  the destination sequence number \hich\af2\dbch\af31505\loch\f2 is marked as valid,
\par \hich\af2\dbch\af31505\loch\f2             //
\par \hich\af2\dbch\af31505\loch\f2             // -  the next hop in the route entry is assigned to be the node from
\par \hich\af2\dbch\af31505\loch\f2             //    which the RREP is received, which is indicated by the source IP
\par \hich\af2\dbch\af31505\loch\f2             //    address field in the IP header,
\par \hich\af2\dbch\af31505\loch\f2        \hich\af2\dbch\af31505\loch\f2      //
\par \hich\af2\dbch\af31505\loch\f2             // -  the hop count is set to the value of the New Hop Count,
\par \hich\af2\dbch\af31505\loch\f2             //
\par \hich\af2\dbch\af31505\loch\f2             // -  the expiry time is set to the current time plus the value of the
\par \hich\af2\dbch\af31505\loch\f2             //    Lifetime in the RREP message,
\par \hich\af2\dbch\af31505\loch\f2             //
\par \hich\af2\dbch\af31505\loch\f2             // -  and the destination sequence number is the Destination Sequence
\par \hich\af2\dbch\af31505\loch\f2             //    Number in the RREP message.
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         // (ii) the Destination Sequence Number in the RREP is greater than
\par \hich\af2\dbch\af31505\loch\f2         //      the node's copy of the des\hich\af2\dbch\af31505\loch\f2 tination sequence number and the
\par \hich\af2\dbch\af31505\loch\f2         //      known value is valid, or
\par \hich\af2\dbch\af31505\loch\f2         else if (destSeqNum > destRouteData->getDestSeqNum()) \{
\par \hich\af2\dbch\af31505\loch\f2             updateRoutingTable(destRoute, sourceAddr, newHopCount, true, destSeqNum, true, simTime() + lifeTime);
\par \hich\af2\dbch\af31505\loch\f2     \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2         else \{
\par \hich\af2\dbch\af31505\loch\f2             // (iii) the sequence numbers are the same, but the route is
\par \hich\af2\dbch\af31505\loch\f2             //       marked as inactive, or
\par \hich\af2\dbch\af31505\loch\f2             if (destSeqNum == destRouteData->getDestSeqNum() && !destRouteData->isActive()) \{
\par \hich\af2\dbch\af31505\loch\f2                 updateRo\hich\af2\dbch\af31505\loch\f2 utingTable(destRoute, sourceAddr, newHopCount, true, destSeqNum, true, simTime() + lifeTime);
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2             // (iv) the sequence numbers are the same, and the New Hop Count is
\par \hich\af2\dbch\af31505\loch\f2             //      smaller than the hop count in route table entry.
\par \hich\af2\dbch\af31505\loch\f2             else if (destSeqNum == destRouteData->getDestSeqNum() && newHopCount < (unsigned int)destRoute->getMetric()) \{
\par \hich\af2\dbch\af31505\loch\f2                 updateRoutingTable(destRoute, sourceAddr, newHopCount, true, destSeqNum, true, simTime() + lifeTime);
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0\pararsid11095480 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 // }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 
\hich\af2\dbch\af31505\loch\f2 C}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 reate}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2  the}{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2  forward route for the destination: this path will be used }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 // }{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 by the originator to send data packets
\par }\pard \ltrpar\ql \li0\ri0\nowidctlpar\wrapdefault\faauto\rin0\lin0\itap0 {\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 else \{    \hich\af2\dbch\af31505\loch\f2 
        destRoute = createRoute(rrep->getDestAddr(), sourceAddr, newHopCount, true, destSeqNum, true, si\hich\af2\dbch\af31505\loch\f2 mTime() + lifeTime);
\par \hich\af2\dbch\af31505\loch\f2         destRouteData = check_and_cast<AODVRouteData *>(destRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2     \}
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     // If the current node is not the node indicated by the Originator IP
\par \hich\af2\dbch\af31505\loch\f2     // IPv4Address in the RREP message AND a forward route has been\hich\af2\dbch\af31505\loch\f2  created or
\par \hich\af2\dbch\af31505\loch\f2     // updated as described above, the node consults its route table entry
\par \hich\af2\dbch\af31505\loch\f2     // for the originating node to determine the next hop for the RREP
\par \hich\af2\dbch\af31505\loch\f2     // packet, and then forwards the RREP towards the originator using the
\par \hich\af2\dbch\af31505\loch\f2     // information in t\hich\af2\dbch\af31505\loch\f2 hat route table entry.
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *originatorRoute = routingTable->findBestMatchingRoute(rrep->getOriginatorAddr());
\par \hich\af2\dbch\af31505\loch\f2     if (getSelfIPAddress() != rrep->getOriginatorAddr()) \{
\par \hich\af2\dbch\af31505\loch\f2         // If a node forwards a RREP over a link that is likely to have erro\hich\af2\dbch\af31505\loch\f2 rs or
\par \hich\af2\dbch\af31505\loch\f2         // be unidirectional, the node SHOULD set the 'A' flag to require that the
\par \hich\af2\dbch\af31505\loch\f2         // recipient of the RREP acknowledge receipt of the RREP by sending a RREP-ACK
\par \hich\af2\dbch\af31505\loch\f2         // message back (see section 6.8).
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (originatorRoute && origi\hich\af2\dbch\af31505\loch\f2 natorRoute->getSource() == this) \{
\par \hich\af2\dbch\af31505\loch\f2             AODVRouteData *originatorRouteData = check_and_cast<AODVRouteData *>(originatorRoute->getProtocolData());
\par 
\par \hich\af2\dbch\af31505\loch\f2             // Also, at each node the (reverse) route used to forward a
\par \hich\af2\dbch\af31505\loch\f2             // RREP has its li\hich\af2\dbch\af31505\loch\f2 fetime changed to be the maximum of (existing-
\par \hich\af2\dbch\af31505\loch\f2             // lifetime, (current time + ACTIVE_ROUTE_TIMEOUT).
\par 
\par \hich\af2\dbch\af31505\loch\f2             simtime_t existingLifeTime = originatorRouteData->getLifeTime();
\par \hich\af2\dbch\af31505\loch\f2             originatorRouteData->setLifeTime(std::max(simTime() + a\hich\af2\dbch\af31505\loch\f2 ctiveRouteTimeout, existingLifeTime));
\par 
\par \hich\af2\dbch\af31505\loch\f2             if (simTime() > rebootTime + deletePeriod || rebootTime == 0) \{
\par \hich\af2\dbch\af31505\loch\f2                 // If a node forwards a RREP over a link that is likely to have errors
\par \hich\af2\dbch\af31505\loch\f2                 // or be unidirectional, the node SHOULD set the 'A' flag to require that
\par \hich\af2\dbch\af31505\loch\f2                 // the recipient of the RREP acknowledge receipt of the RREP by sending a
\par \hich\af2\dbch\af31505\loch\f2                 // RREP-ACK message back (see section 6.8).
\par 
\par \hich\af2\dbch\af31505\loch\f2                \hich\af2\dbch\af31505\loch\f2  if (rrep->getAckRequiredFlag()) \{
\par \hich\af2\dbch\af31505\loch\f2                     AODVRREPACK *rrepACK = createRREPACK();
\par \hich\af2\dbch\af31505\loch\f2                     sendRREPACK(rrepACK, sourceAddr);
\par \hich\af2\dbch\af31505\loch\f2                     rrep->setAckRequiredFlag(false);
\par \hich\af2\dbch\af31505\loch\f2                 \}
\par 
\par \hich\af2\dbch\af31505\loch\f2                 // When any node tr\hich\af2\dbch\af31505\loch\f2 ansmits a RREP, the precursor list for the
\par \hich\af2\dbch\af31505\loch\f2                 // corresponding destination node is updated by adding to it
\par \hich\af2\dbch\af31505\loch\f2                 // the next hop node to which the RREP is forwarded.
\par 
\par \hich\af2\dbch\af31505\loch\f2                 destRouteData->addPrecursor(originatorRoute->getGa\hich\af2\dbch\af31505\loch\f2 teway());
\par 
\par \hich\af2\dbch\af31505\loch\f2                 // Finally, the precursor list for the next hop towards the
\par \hich\af2\dbch\af31505\loch\f2                 // destination is updated to contain the next hop towards the
\par \hich\af2\dbch\af31505\loch\f2                 // source (originator).
\par 
\par \hich\af2\dbch\af31505\loch\f2                 IPv4Route *nextHopToDestRoute = ro\hich\af2\dbch\af31505\loch\f2 utingTable->findBestMatchingRoute(destRoute->getGateway());
\par \hich\af2\dbch\af31505\loch\f2                 ASSERT(nextHopToDestRoute);
\par \hich\af2\dbch\af31505\loch\f2                 AODVRouteData *nextHopToDestRouteData = check_and_cast<AODVRouteData *>(nextHopToDestRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2                 nextHopT\hich\af2\dbch\af31505\loch\f2 oDestRouteData->addPrecursor(originatorRoute->getGateway());
\par 
\par \hich\af2\dbch\af31505\loch\f2                 AODVRREP *outgoingRREP = rrep->dup();
\par \hich\af2\dbch\af31505\loch\f2                 forwardRREP(outgoingRREP, originatorRoute->getGateway(), 100);
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else
\par \hich\af2\dbch\af31505\loch\f2             EV_ERROR \hich\af2\dbch\af31505\loch\f2 << "Reverse route doesn't exist. Dropping the RREP message" << endl;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         if (hasOngoingRouteDiscovery(rrep->getDestAddr())) \{
\par \hich\af2\dbch\af31505\loch\f2             EV_INFO << "The Route Reply has arrived for our Route Request to node " << rrep->getDestAddr() <<\hich\af2\dbch\af31505\loch\f2  endl;
\par \hich\af2\dbch\af31505\loch\f2             updateRoutingTable(destRoute, sourceAddr, newHopCount, true, destSeqNum, true, simTime() + lifeTime);
\par \hich\af2\dbch\af31505\loch\f2             completeRouteDiscovery(rrep->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     delete rrep;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::updateRoutingTable(IPv4\hich\af2\dbch\af31505\loch\f2 Route *route, const IPv4Address& nextHop, unsigned int hopCount, bool hasValidDestNum, unsigned int destSeqNum, bool isActive, simtime_t lifeTime)

\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_DETAIL << "Updating existing route: " << route << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     route->setGateway(nextHop);
\par \hich\af2\dbch\af31505\loch\f2     route->\hich\af2\dbch\af31505\loch\f2 setMetric(hopCount);
\par 
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *routingData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(routingData != NULL);
\par 
\par \hich\af2\dbch\af31505\loch\f2     routingData->setLifeTime(lifeTime);
\par \hich\af2\dbch\af31505\loch\f2     routingData->setDestSeqNum(destSeqNum);
\par \hich\af2\dbch\af31505\loch\f2     routingData->setIsActive(isActive);
\par \hich\af2\dbch\af31505\loch\f2     routingData->setHasValidDestNum(hasValidDestNum);
\par 
\par \hich\af2\dbch\af31505\loch\f2     EV_DETAIL << "Route updated: " << route << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     scheduleExpungeRoutes();
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendAODVPacket(AODVControlPacket *packet, const IPv4Addre\hich\af2\dbch\af31505\loch\f2 ss& destAddr, unsigned int timeToLive, double delay)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(timeToLive != 0);
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4ControlInfo *networkProtocolControlInfo = new IPv4ControlInfo();
\par 
\par \hich\af2\dbch\af31505\loch\f2     networkProtocolControlInfo->setTimeToLive(timeToLive);
\par 
\par \hich\af2\dbch\af31505\loch\f2     networkProtocolControlInfo->setPr\hich\af2\dbch\af31505\loch\f2 otocol(IP_PROT_MANET);
\par \hich\af2\dbch\af31505\loch\f2     networkProtocolControlInfo->setDestAddr(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     networkProtocolControlInfo->setSrcAddr(getSelfIPAddress());
\par 
\par \hich\af2\dbch\af31505\loch\f2     // TODO: Implement: support for multiple interfaces
\par \hich\af2\dbch\af31505\loch\f2     InterfaceEntry *ifEntry = interfaceTable->getInterfac\hich\af2\dbch\af31505\loch\f2 eByName("wlan0");
\par \hich\af2\dbch\af31505\loch\f2     networkProtocolControlInfo->setInterfaceId(ifEntry->getInterfaceId());
\par 
\par \hich\af2\dbch\af31505\loch\f2     UDPPacket *udpPacket = new UDPPacket(packet->getName());
\par \hich\af2\dbch\af31505\loch\f2     udpPacket->encapsulate(packet);
\par \hich\af2\dbch\af31505\loch\f2     udpPacket->setSourcePort(aodvUDPPort);
\par \hich\af2\dbch\af31505\loch\f2     udpPacket->setDestinationPort(aodvUDPPort);
\par \hich\af2\dbch\af31505\loch\f2     udpPacket->setControlInfo(dynamic_cast<cObject *>(networkProtocolControlInfo));
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (destAddr.isLimitedBroadcastAddress())
\par \hich\af2\dbch\af31505\loch\f2         lastBroadcastTime = simTime();
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (delay == 0)
\par \hich\af2\dbch\af31505\loch\f2         send(udpP\hich\af2\dbch\af31505\loch\f2 acket, "ipOut");
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         sendDelayed(udpPacket, delay, "ipOut");
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleRREQ(AODVRREQ *rreq, const IPv4Address& sourceAddr, unsigned int timeToLive)
\par \{
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 // Check the blacklist node list before sending the route request. }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     EV_INFO << "AODV Route Request arrived with source addr: " << sourceAddr\hich\af2\dbch\af31505\loch\f2  << " originator addr: " << rreq->getOriginatorAddr()
\par \hich\af2\dbch\af31505\loch\f2             << " destination addr: " << rreq->getDestAddr() << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // A node ignores all RREQs received from any node in its blacklist set.
\par 
\par \hich\af2\dbch\af31505\loch\f2     std::map<IPv4Address, simtime_t>::iterator blackLi\hich\af2\dbch\af31505\loch\f2 stIt = blacklist.find(sourceAddr);
\par \hich\af2\dbch\af31505\loch\f2     if (blackListIt != blacklist.end()) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "The sender node " << sourceAddr << " is in our blacklist. Ignoring the Route Request" << endl;
\par \hich\af2\dbch\af31505\loch\f2         delete rreq;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2     // When a node r\hich\af2\dbch\af31505\loch\f2 eceives a RREQ, it first creates or updates a route to
\par \hich\af2\dbch\af31505\loch\f2     // the previous hop without a valid sequence number (see section 6.2).
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *previousHopRoute = routingTable->findBestMatchingRoute(sourceAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (!previousHopRoute || previousHopRoute->getSource() != this) \{
\par \hich\af2\dbch\af31505\loch\f2         // create without valid sequence number
\par \hich\af2\dbch\af31505\loch\f2         previousHopRoute = createRoute(sourceAddr, sourceAddr, 1, false, rreq->getOriginatorSeqNum(), true, simTime() + activeRouteTimeout\hich\af2\dbch\af31505\loch\f2 );
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         updateRoutingTable(previousHopRoute, sourceAddr, 1, false, rreq->getOriginatorSeqNum(), true, simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // then checks to determine whether it has received a RREQ with the same
\par \hich\af2\dbch\af31505\loch\f2     // Originator IP addr\hich\af2\dbch\af31505\loch\f2 ess and RREQ ID within at least the last PATH_DISCOVERY_TIME.
\par \hich\af2\dbch\af31505\loch\f2     // If such a RREQ has been received, the node silently discards the newly received RREQ.
\par 
\par \hich\af2\dbch\af31505\loch\f2     RREQIdentifier rreqIdentifier(rreq->getOriginatorAddr(), rreq->getRreqId());
\par \hich\af2\dbch\af31505\loch\f2     std::map<RREQId\hich\af2\dbch\af31505\loch\f2 entifier, simtime_t, RREQIdentifierCompare>::iterator checkRREQArrivalTime = rreqsArrivalTime.find(rreqIdentifier);
\par \hich\af2\dbch\af31505\loch\f2     if (checkRREQArrivalTime != rreqsArrivalTime.end() && simTime() - checkRREQArrivalTime->second <= pathDiscoveryTime) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN <\hich\af2\dbch\af31505\loch\f2 < "The same packet has arrived within PATH_DISCOVERY_TIME= " << pathDiscoveryTime << ". Discarding it" << endl;
\par \hich\af2\dbch\af31505\loch\f2         delete rreq;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // update or create
\par \hich\af2\dbch\af31505\loch\f2     rreqsArrivalTime[rreqIdentifier] = simTime();
\par 
\par \hich\af2\dbch\af31505\loch\f2     // First, it first in\hich\af2\dbch\af31505\loch\f2 crements the hop count value in the RREQ by one, to
\par \hich\af2\dbch\af31505\loch\f2     // account for the new hop through the intermediate node.
\par 
\par \hich\af2\dbch\af31505\loch\f2     rreq->setHopCount(rreq->getHopCount() + 1);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Then the node searches for a reverse route to the Originator IP Address (see
\par \hich\af2\dbch\af31505\loch\f2     // section 6.2), using longest-prefix matching.
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *reverseRoute = routingTable->findBestMatchingRoute(rreq->getOriginatorAddr());
\par 
\par \hich\af2\dbch\af31505\loch\f2     // If need be, the route is created, or updated using the Originator Sequence Number from the
\par \hich\af2\dbch\af31505\loch\f2     // RRE\hich\af2\dbch\af31505\loch\f2 Q in its routing table.
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // When the reverse route is created or updated, the following actions on
\par \hich\af2\dbch\af31505\loch\f2     // the route are also carried out:
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   1. the Originator Sequence Number from the RREQ is compared to the
\par \hich\af2\dbch\af31505\loch\f2     //      corresponding\hich\af2\dbch\af31505\loch\f2  destination sequence number in the route table entry
\par \hich\af2\dbch\af31505\loch\f2     //      and copied if greater than the existing value there
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   2. the valid sequence number field is set to true;
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   3. the next hop in the routing table becomes the node f\hich\af2\dbch\af31505\loch\f2 rom which the
\par \hich\af2\dbch\af31505\loch\f2     //      RREQ was received (it is obtained from the source IP address in
\par \hich\af2\dbch\af31505\loch\f2     //      the IP header and is often not equal to the Originator IP Address
\par \hich\af2\dbch\af31505\loch\f2     //      field in the RREQ message);
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   4. the hop count is copied from \hich\af2\dbch\af31505\loch\f2 the Hop Count in the RREQ message;
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   Whenever a RREQ message is received, the Lifetime of the reverse
\par \hich\af2\dbch\af31505\loch\f2     //   route entry for the Originator IP address is set to be the maximum of
\par \hich\af2\dbch\af31505\loch\f2     //   (ExistingLifetime, MinimalLifetime), where
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //   MinimalLifetime = (current time + 2*NET_TRAVERSAL_TIME - 2*HopCount*NODE_TRAVERSAL_TIME).
\par 
\par \hich\af2\dbch\af31505\loch\f2     unsigned int hopCount = rreq->getHopCount();
\par \hich\af2\dbch\af31505\loch\f2     simtime_t minimalLifeTime = simTime() + 2 * netTraversalTime - 2 * hopCount * nodeTraversalTime;
\par \hich\af2\dbch\af31505\loch\f2     si\hich\af2\dbch\af31505\loch\f2 mtime_t newLifeTime = std::max(simTime(), minimalLifeTime);
\par \hich\af2\dbch\af31505\loch\f2     int rreqSeqNum = rreq->getOriginatorSeqNum();
\par \hich\af2\dbch\af31505\loch\f2     if (!reverseRoute || reverseRoute->getSource() != this) \{    // create
\par \hich\af2\dbch\af31505\loch\f2         // This reverse route will be needed if the node receives a RRE\hich\af2\dbch\af31505\loch\f2 P back to the
\par \hich\af2\dbch\af31505\loch\f2         // node that originated the RREQ (identified by the Originator IP Address).
\par \hich\af2\dbch\af31505\loch\f2         reverseRoute = createRoute(rreq->getOriginatorAddr(), sourceAddr, hopCount, true, rreqSeqNum, true, newLifeTime);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteDa\hich\af2\dbch\af31505\loch\f2 ta *routeData = check_and_cast<AODVRouteData *>(reverseRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         int routeSeqNum = routeData->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2         int newSeqNum = std::max(routeSeqNum, rreqSeqNum);
\par \hich\af2\dbch\af31505\loch\f2         int newHopCount = rreq->getHopCount();    // Note: al\hich\af2\dbch\af31505\loch\f2 ready incremented by 1.
\par \hich\af2\dbch\af31505\loch\f2         int routeHopCount = reverseRoute->getMetric();
\par \hich\af2\dbch\af31505\loch\f2         // The route is only updated if the new sequence number is either
\par \hich\af2\dbch\af31505\loch\f2         //
\par \hich\af2\dbch\af31505\loch\f2         //   (i)       higher than the destination sequence number in the route
\par \hich\af2\dbch\af31505\loch\f2         //  \hich\af2\dbch\af31505\loch\f2            table, or
\par \hich\af2\dbch\af31505\loch\f2         //
\par \hich\af2\dbch\af31505\loch\f2         //   (ii)      the sequence numbers are equal, but the hop count (of the
\par \hich\af2\dbch\af31505\loch\f2         //             new information) plus one, is smaller than the existing hop
\par \hich\af2\dbch\af31505\loch\f2         //             count in the routing table, or
\par \hich\af2\dbch\af31505\loch\f2       \hich\af2\dbch\af31505\loch\f2   //
\par \hich\af2\dbch\af31505\loch\f2         //   (iii)     the sequence number is unknown.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (rreqSeqNum > routeSeqNum ||
\par \hich\af2\dbch\af31505\loch\f2             (rreqSeqNum == routeSeqNum && newHopCount < routeHopCount) ||
\par \hich\af2\dbch\af31505\loch\f2             rreq->getUnknownSeqNumFlag())
\par \hich\af2\dbch\af31505\loch\f2         \{
\par \hich\af2\dbch\af31505\loch\f2             up\hich\af2\dbch\af31505\loch\f2 dateRoutingTable(reverseRoute, sourceAddr, hopCount, true, newSeqNum, true, newLifeTime);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // A node generates a RREP if either:
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // (i)       it is itself the destination, or
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // (ii)      it has an active route to \hich\af2\dbch\af31505\loch\f2 the destination, the destination
\par \hich\af2\dbch\af31505\loch\f2     //           sequence number in the node's existing route table entry
\par \hich\af2\dbch\af31505\loch\f2     //           for the destination is valid and greater than or equal to
\par \hich\af2\dbch\af31505\loch\f2     //           the Destination Sequence Number of the RREQ (comparison
\par \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2    //           using signed 32-bit arithmetic), and the "destination only"
\par \hich\af2\dbch\af31505\loch\f2     //           ('D') flag is NOT set.
\par 
\par \hich\af2\dbch\af31505\loch\f2 // After}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 ,}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2  a node receives a RREQ and responds with a RREP, it discards
\par \hich\af2\dbch\af31505\loch\f2 // the RREQ.  If the RREQ has the 'G' flag set, and the inter\hich\af2\dbch\af31505\loch\f2 mediate
\par \hich\af2\dbch\af31505\loch\f2 // node returns a RREP to the originati}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 ng node, it MUST also u\hich\af2\dbch\af31505\loch\f2 nicast 
\par \hich\af2\dbch\af31505\loch\f2 // \hich\af2\dbch\af31505\loch\f2 a}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 gratuitous RREP to the destination node.
\par 
\par \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 IPv4Route *destRoute = routingTable->findBestMatchingRoute(rreq->getDestAddr());
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *destRouteData = dest\hich\af2\dbch\af31505\loch\f2 Route ? dynamic_cast<AODVRouteData *>(destRoute->getProtocolData()) : NULL;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // check (i)
\par \hich\af2\dbch\af31505\loch\f2     if (rreq->getDestAddr() == getSelfIPAddress()) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "I am the destination node for which the route was requested" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2         // create RREP
\par \hich\af2\dbch\af31505\loch\f2         AODVRREP *rrep = createRREP(rreq, destRoute, reverseRoute, sourceAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // send to the originator
\par \hich\af2\dbch\af31505\loch\f2         sendRREP(rrep, rreq->getOriginatorAddr(), 255);
\par 
\par \hich\af2\dbch\af31505\loch\f2         delete rreq;
\par \hich\af2\dbch\af31505\loch\f2         return;    // discard RREQ, in t\hich\af2\dbch\af31505\loch\f2 his case, we do not forward it.
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // check (ii)
\par \hich\af2\dbch\af31505\loch\f2     if (destRouteData && destRouteData->isActive() && destRouteData->hasValidDestNum() &&
\par \hich\af2\dbch\af31505\loch\f2         destRouteData->getDestSeqNum() >= rreq->getDestSeqNum())
\par \hich\af2\dbch\af31505\loch\f2     \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "I am an intermedia\hich\af2\dbch\af31505\loch\f2 te node who has information about a route to " << rreq->getDestAddr() << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (destRoute->getGateway() == sourceAddr) \{
\par \hich\af2\dbch\af31505\loch\f2             EV_WARN << "This RREP would make a loop. Dropping it" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2             delete rreq;
\par \hich\af2\dbch\af31505\loch\f2             return;
\par \hich\af2\dbch\af31505\loch\f2   \hich\af2\dbch\af31505\loch\f2       \}
\par 
\par \hich\af2\dbch\af31505\loch\f2         // create RREP
\par \hich\af2\dbch\af31505\loch\f2         AODVRREP *rrep = createRREP(rreq, destRoute, reverseRoute, sourceAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // send to the originator
\par \hich\af2\dbch\af31505\loch\f2         sendRREP(rrep, rreq->getOriginatorAddr(), 255);
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2         if (rreq->getGratuitousRREPFlag()) \{
\par \hich\af2\dbch\af31505\loch\f2             // The gratuitous RREP is then sent to the next hop along the path to
\par \hich\af2\dbch\af31505\loch\f2             // the destination node, just as if the destination node had already
\par \hich\af2\dbch\af31505\loch\f2             // issued a RREQ for the originating node and this RREP was produced in
\par \hich\af2\dbch\af31505\loch\f2          \hich\af2\dbch\af31505\loch\f2    // response to that (fictitious) RREQ.
\par 
\par \hich\af2\dbch\af31505\loch\f2             IPv4Route *originatorRoute = routingTable->findBestMatchingRoute(rreq->getOriginatorAddr());
\par \hich\af2\dbch\af31505\loch\f2             AODVRREP *grrep = createGratuitousRREP(rreq, originatorRoute);
\par \hich\af2\dbch\af31505\loch\f2             sendGRREP(grrep, rreq\hich\af2\dbch\af31505\loch\f2 ->getDestAddr(), 100);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par 
\par \hich\af2\dbch\af31505\loch\f2         delete rreq;
\par \hich\af2\dbch\af31505\loch\f2         return;    // discard RREQ, in this case, we also do not forward it.
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     // If a node does not generate a RREP (following the processing rules in
\par \hich\af2\dbch\af31505\loch\f2     // section 6.6), and if the incoming \hich\af2\dbch\af31505\loch\f2 IP header has TTL larger than 1,
\par \hich\af2\dbch\af31505\loch\f2     // the node updates and broadcasts the RREQ to address 255.255.255.255
\par \hich\af2\dbch\af31505\loch\f2     // on each of its configured interfaces (see section 6.14).  To update
\par \hich\af2\dbch\af31505\loch\f2     // the RREQ, the TTL or hop limit field in the outgoing IP header is
\par \hich\af2\dbch\af31505\loch\f2     // decreased by one, and the Hop Count field in the RREQ message is
\par \hich\af2\dbch\af31505\loch\f2     // incremented by one, to account for the new hop through the
\par \hich\af2\dbch\af31505\loch\f2     // intermediate node. (!) Lastly, the Destination Sequence number for the
\par \hich\af2\dbch\af31505\loch\f2     // requested destination is set to the maximum of the corresponding
\par \hich\af2\dbch\af31505\loch\f2     // value received in the RREQ message, and the destination sequence
\par \hich\af2\dbch\af31505\loch\f2     // value currently maintained by the node for the requested destination.
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid11095480 
\par \hich\af2\dbch\af31505\loch\f2     // \hich\af2\dbch\af31505\loch\f2 T}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 he forwarding node\hich\af2\dbch\af31505\loch\f2  MUST NOT modify its maintained value for
\par \hich\af2\dbch\af31505\loch\f2     // the destination sequence number, even if the value received in the
\par \hich\af2\dbch\af31505\loch\f2     // incoming RREQ is larger than the value currently maintained by the
\par \hich\af2\dbch\af31505\loch\f2     // forwarding node.}{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (timeToLive > 0 && (simTime() > re\hich\af2\dbch\af31505\loch\f2 bootTime + deletePeriod || rebootTime == 0)) \{
\par \hich\af2\dbch\af31505\loch\f2         if (destRouteData)
\par \hich\af2\dbch\af31505\loch\f2             rreq->setDestSeqNum(std::max(destRouteData->getDestSeqNum(), rreq->getDestSeqNum()));
\par \hich\af2\dbch\af31505\loch\f2         rreq->setUnknownSeqNumFlag(false);
\par 
\par \hich\af2\dbch\af31505\loch\f2         AODVRREQ *outgoingRREQ = rreq->d\hich\af2\dbch\af31505\loch\f2 up();
\par \hich\af2\dbch\af31505\loch\f2         forwardRREQ(outgoingRREQ, timeToLive);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "Can't forward the RREQ because of its small (<= 1) TTL: " << timeToLive << " or the AODV reboot has not completed yet" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     delete rreq;
\par \}
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2 IPv4Route *AODVRout\hich\af2\dbch\af31505\loch\f2 ing::createRoute(const IPv4Address& destAddr, const IPv4Address& nextHop,
\par \hich\af2\dbch\af31505\loch\f2         unsigned int hopCount, bool hasValidDestNum, unsigned int destSeqNum,
\par \hich\af2\dbch\af31505\loch\f2         bool isActive, simtime_t lifeTime)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *newRoute = new IPv4Route();
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteDat\hich\af2\dbch\af31505\loch\f2 a *newProtocolData = new AODVRouteData();
\par 
\par \hich\af2\dbch\af31505\loch\f2     newProtocolData->setHasValidDestNum(hasValidDestNum);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // active route
\par \hich\af2\dbch\af31505\loch\f2     newProtocolData->setIsActive(isActive);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // A route towards a destination that has a routing table entry
\par \hich\af2\dbch\af31505\loch\f2   \hich\af2\dbch\af31505\loch\f2   // that is marked as valid.  Only active routes can be used to
\par \hich\af2\dbch\af31505\loch\f2     // forward data packets.
\par 
\par \hich\af2\dbch\af31505\loch\f2     newProtocolData->setLifeTime(lifeTime);
\par \hich\af2\dbch\af31505\loch\f2     newProtocolData->setDestSeqNum(destSeqNum);
\par 
\par \hich\af2\dbch\af31505\loch\f2     InterfaceEntry *ifEntry = interfaceTable->getInterfaceByName("wl\hich\af2\dbch\af31505\loch\f2 an0");    // TODO: IMPLEMENT: multiple interfaces
\par \hich\af2\dbch\af31505\loch\f2     if (ifEntry)
\par \hich\af2\dbch\af31505\loch\f2         newRoute->setInterface(ifEntry);
\par 
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setDestination(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setSourceType(IPv4Route::AODV);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setSource(this);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setProtocolData(\hich\af2\dbch\af31505\loch\f2 newProtocolData);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setMetric(hopCount);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setGateway(nextHop);
\par \hich\af2\dbch\af31505\loch\f2     newRoute->setNetmask(IPv4Address::ALLONES_ADDRESS);    // TODO:
\par 
\par \hich\af2\dbch\af31505\loch\f2     EV_DETAIL << "Adding new route " << newRoute << endl;
\par \hich\af2\dbch\af31505\loch\f2     routingTable->addRoute(newRoute);
\par \hich\af2\dbch\af31505\loch\f2    \hich\af2\dbch\af31505\loch\f2  scheduleExpungeRoutes();
\par \hich\af2\dbch\af31505\loch\f2     return newRoute;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::receiveChangeNotification(int signalID, const cObject *obj)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     Enter_Method("receiveChangeNotification");
\par \hich\af2\dbch\af31505\loch\f2     if (signalID == NF_LINK_BREAK) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_DETAIL << "Received link break signal" << endl;
\par \hich\af2\dbch\af31505\loch\f2         // XXX: This is a hack for supporting both IdealMac and Ieee80211Mac.
\par \hich\af2\dbch\af31505\loch\f2         Ieee80211Frame *ieee80211Frame = dynamic_cast<Ieee80211Frame *>(const_cast<cObject *>(obj));
\par \hich\af2\dbch\af31505\loch\f2         IPv4Datagr\hich\af2\dbch\af31505\loch\f2 am *datagram = dynamic_cast<IPv4Datagram *> (ieee80211Frame == NULL ? const_cast<cObject *>(obj) : ieee80211Frame->getEncapsulatedPacket());
\par \hich\af2\dbch\af31505\loch\f2         if (datagram) \{
\par \hich\af2\dbch\af31505\loch\f2             const IPv4Address& unreachableAddr = datagram->getDestAddress();
\par \hich\af2\dbch\af31505\loch\f2             if\hich\af2\dbch\af31505\loch\f2  (true) \{
\par \hich\af2\dbch\af31505\loch\f2                 // A node initiates processing for a RERR message in three situations:
\par \hich\af2\dbch\af31505\loch\f2                 //
\par \hich\af2\dbch\af31505\loch\f2                 //   (i)     if it detects a link break for the next hop of an active
\par \hich\af2\dbch\af31505\loch\f2                 //           route in its routing tabl\hich\af2\dbch\af31505\loch\f2 e while transmitting data (and
\par \hich\af2\dbch\af31505\loch\f2                 //           route repair, if attempted, was unsuccessful), or
\par 
\par \hich\af2\dbch\af31505\loch\f2                 // TODO: Implement: local repair
\par 
\par \hich\af2\dbch\af31505\loch\f2                 IPv4Route *route = routingTable->findBestMatchingRoute(unreachableAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2      \hich\af2\dbch\af31505\loch\f2            if (route && route->getSource() == this)
\par \hich\af2\dbch\af31505\loch\f2                     handleLinkBreakSendRERR(route->getGateway());
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else
\par \hich\af2\dbch\af31505\loch\f2             throw cRuntimeError("Unknown packet type in NF_LINK_BREAK notification");
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleLinkBreakSendRERR(const IPv4Address& unreachableAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // For case (i), the node first makes a list of unreachable destinations
\par \hich\af2\dbch\af31505\loch\f2     // consisting of the unreachable neighbor and any additional
\par \hich\af2\dbch\af31505\loch\f2     // destinations (or subnets, s\hich\af2\dbch\af31505\loch\f2 ee section 7) in the local routing table
\par \hich\af2\dbch\af31505\loch\f2     // that use the unreachable neighbor as the next hop.
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Just before transmitting the RERR, certain updates are made on the
\par \hich\af2\dbch\af31505\loch\f2     // routing table that may affect the destination sequence numbers for
\par \hich\af2\dbch\af31505\loch\f2     // t\hich\af2\dbch\af31505\loch\f2 he unreachable destinations.  For each one of these destinations,
\par \hich\af2\dbch\af31505\loch\f2     // the corresponding routing table entry is updated as follows:
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // 1. The destination sequence number of this routing entry, if it
\par \hich\af2\dbch\af31505\loch\f2     //    exists and is valid, is incremente\hich\af2\dbch\af31505\loch\f2 d for cases (i) and (ii) above,
\par \hich\af2\dbch\af31505\loch\f2     //    and copied from the incoming RERR in case (iii) above.
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // 2. The entry is invalidated by marking the route entry as invalid
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     // 3. The Lifetime field is updated to current time plus DELETE_PERI\hich\af2\dbch\af31505\loch\f2 OD.
\par \hich\af2\dbch\af31505\loch\f2     //    Before this time, the entry SHOULD NOT be deleted.
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *unreachableRoute = routingTable->findBestMatchingRoute(unreachableAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (!unreachableRoute || unreachableRoute->getSource() != this)
\par \hich\af2\dbch\af31505\loch\f2         return;
\par 
\par \hich\af2\dbch\af31505\loch\f2     std::vector<UnreachableNode> unreachableNodes;
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *unreachableRouteData = check_and_cast<AODVRouteData *>(unreachableRoute->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2     UnreachableNode node;
\par \hich\af2\dbch\af31505\loch\f2     node.addr = unreachableAddr;
\par \hich\af2\dbch\af31505\loch\f2     node.seqNum = unreachableRoute\hich\af2\dbch\af31505\loch\f2 Data->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2     unreachableNodes.push_back(node);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // For case (i), the node first makes a list of unreachable destinations
\par \hich\af2\dbch\af31505\loch\f2     // consisting of the unreachable neighbor and any additional destinations
\par \hich\af2\dbch\af31505\loch\f2     // (or subnets, see section 7) in t\hich\af2\dbch\af31505\loch\f2 he local routing table that use the
\par \hich\af2\dbch\af31505\loch\f2     // unreachable neighbor as the next hop.
\par 
\par \hich\af2\dbch\af31505\loch\f2     for (int i = 0; i < routingTable->getNumRoutes(); i++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->getRoute(i);
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (route->getGateway() == unreachableAddr) \{
\par \hich\af2\dbch\af31505\loch\f2     \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par 
\par \hich\af2\dbch\af31505\loch\f2             if (routeData->hasValidDestNum())
\par \hich\af2\dbch\af31505\loch\f2                 routeData->setDestSeqNum(routeData->getDestSeqNum() + 1);
\par 
\par \hich\af2\dbch\af31505\loch\f2             EV_DETAIL << "Marking route \hich\af2\dbch\af31505\loch\f2 to " << route->getDestination() << " as inactive" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2             routeData->setIsActive(false);
\par \hich\af2\dbch\af31505\loch\f2             routeData->setLifeTime(simTime() + deletePeriod);
\par \hich\af2\dbch\af31505\loch\f2             scheduleExpungeRoutes();
\par 
\par \hich\af2\dbch\af31505\loch\f2             UnreachableNode node;
\par \hich\af2\dbch\af31505\loch\f2             node.addr = route->getDestination();
\par \hich\af2\dbch\af31505\loch\f2             node.seqNum = routeData->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2             unreachableNodes.push_back(node);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // The neighboring node(s) that should receive the RERR are all those
\par \hich\af2\dbch\af31505\loch\f2     // that belo\hich\af2\dbch\af31505\loch\f2 ng to a precursor list of at least one of the unreachable
\par \hich\af2\dbch\af31505\loch\f2     // destination(s) in the newly created RERR.  In case there is only one
\par \hich\af2\dbch\af31505\loch\f2     // unique neighbor that needs to receive the RERR, the RERR SHOULD be
\par \hich\af2\dbch\af31505\loch\f2     // unicast toward that neighbor.  Otherwise \hich\af2\dbch\af31505\loch\f2 the RERR is typically sent
\par \hich\af2\dbch\af31505\loch\f2     // to the local broadcast address (Destination IP == 255.255.255.255,
\par \hich\af2\dbch\af31505\loch\f2     // TTL == 1) with the unreachable destinations, and their corresponding
\par \hich\af2\dbch\af31505\loch\f2     // destination sequence numbers, included in the packet.
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (rerrCount\hich\af2\dbch\af31505\loch\f2  >= rerrRatelimit) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "A node should not generate more than RERR_RATELIMIT RERR messages per second. Canceling sending RERR" << endl;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     AODVRERR *rerr = createRERR(unreachableNodes);
\par \hich\af2\dbch\af31505\loch\f2     rerrCount++;
\par 
\par \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid11095480 \hich\af2\dbch\af31505\loch\f2 Check the status of error message and accord
\hich\af2\dbch\af31505\loch\f2 ingly send the message. }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Broadcasting Route Error message with TTL=1" << endl;
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rerr, IPv4Address::ALLONES_ADDRESS, 1, jitterPar->doubleValue());
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRERR *AODVRouting::createRERR(const std::vector<UnreachableNode>& unreachableNodes)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     AODVRERR *rerr = new AODVRERR("AODV-RERR");
\par \hich\af2\dbch\af31505\loch\f2     unsigned int destCount = unreachableNodes.size();
\par 
\par \hich\af2\dbch\af31505\loch\f2     rerr->setPacketType(RERR);
\par \hich\af2\dbch\af31505\loch\f2     rerr->setDestCount(destCount);
\par \hich\af2\dbch\af31505\loch\f2     rerr->setUnreachableNodesArraySize(destCount);
\par 
\par \hich\af2\dbch\af31505\loch\f2     for (unsigned int i = 0; i < de\hich\af2\dbch\af31505\loch\f2 stCount; i++) \{
\par \hich\af2\dbch\af31505\loch\f2         UnreachableNode node;
\par \hich\af2\dbch\af31505\loch\f2         node.addr = unreachableNodes[i].addr;
\par \hich\af2\dbch\af31505\loch\f2         node.seqNum = unreachableNodes[i].seqNum;
\par \hich\af2\dbch\af31505\loch\f2         rerr->setUnreachableNodes(i, node);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     return rerr;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleRERR(AODVRERR *rerr,\hich\af2\dbch\af31505\loch\f2  const IPv4Address& sourceAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "AODV Route Error arrived with source addr: " << sourceAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // A node initiates processing for a RERR message in three situations:
\par \hich\af2\dbch\af31505\loch\f2     // (iii)   if it receives a RERR from a neighbor for one o\hich\af2\dbch\af31505\loch\f2 r more
\par \hich\af2\dbch\af31505\loch\f2     //         active routes.
\par \hich\af2\dbch\af31505\loch\f2     unsigned int unreachableArraySize = rerr->getUnreachableNodesArraySize();
\par \hich\af2\dbch\af31505\loch\f2     std::vector<UnreachableNode> unreachableNeighbors;
\par 
\par \hich\af2\dbch\af31505\loch\f2     for (int i = 0; i < routingTable->getNumRoutes(); i++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->getRoute(i);
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = route ? dynamic_cast<AODVRouteData *>(route->getProtocolData()) : NULL;
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (!routeData)
\par \hich\af2\dbch\af31505\loch\f2             continue;
\par 
\par \hich\af2\dbch\af31505\loch\f2         // For case (iii), the list should cons\hich\af2\dbch\af31505\loch\f2 ist of those destinations in the RERR
\par \hich\af2\dbch\af31505\loch\f2         // for which there exists a corresponding entry in the local routing
\par \hich\af2\dbch\af31505\loch\f2         // table that has the transmitter of the received RERR as the next hop.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (route->getGateway() == sourceAddr) \{
\par \hich\af2\dbch\af31505\loch\f2            \hich\af2\dbch\af31505\loch\f2  for (unsigned int j = 0; j < unreachableArraySize; j++) \{
\par \hich\af2\dbch\af31505\loch\f2                 if (route->getDestination() == rerr->getUnreachableNodes(j).addr) \{
\par \hich\af2\dbch\af31505\loch\f2                     // 1. The destination sequence number of this routing entry, if it
\par \hich\af2\dbch\af31505\loch\f2                     // exi\hich\af2\dbch\af31505\loch\f2 sts and is valid, is incremented for cases (i) and (ii) above,
\par \hich\af2\dbch\af31505\loch\f2                     // ! and copied from the incoming RERR in case (iii) above.
\par 
\par \hich\af2\dbch\af31505\loch\f2                     routeData->setDestSeqNum(rerr->getUnreachableNodes(j).seqNum);
\par \hich\af2\dbch\af31505\loch\f2                     routeData\hich\af2\dbch\af31505\loch\f2 ->setIsActive(false);    // it means invalid, see 3. AODV Terminology p.3. in RFC 3561
\par \hich\af2\dbch\af31505\loch\f2                     routeData->setLifeTime(simTime() + deletePeriod);
\par 
\par \hich\af2\dbch\af31505\loch\f2                     // The RERR should contain those destinations that are part of
\par \hich\af2\dbch\af31505\loch\f2                \hich\af2\dbch\af31505\loch\f2      // the created list of unreachable destinations and have a non-empty
\par \hich\af2\dbch\af31505\loch\f2                     // precursor list.
\par 
\par \hich\af2\dbch\af31505\loch\f2                     if (routeData->getPrecursorList().size() > 0) \{
\par \hich\af2\dbch\af31505\loch\f2                         UnreachableNode node;
\par \hich\af2\dbch\af31505\loch\f2                         node.addr = route->getDestination();
\par \hich\af2\dbch\af31505\loch\f2                         node.seqNum = routeData->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2                         unreachableNeighbors.push_back(node);
\par \hich\af2\dbch\af31505\loch\f2                     \}
\par \hich\af2\dbch\af31505\loch\f2                     scheduleExpungeRoutes();
\par \hich\af2\dbch\af31505\loch\f2                 \}
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (rerrCount >= rerrRatelimit) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "A node should not generate more than RERR_RATELIMIT RERR messages per second. Canceling sending RERR" << endl;
\par \hich\af2\dbch\af31505\loch\f2         delete rerr;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2    \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (unreachableNeighbors.size() > 0 && (simTime() > rebootTime + deletePeriod || rebootTime == 0)) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "Sending RERR to inform our neighbors about link breaks." << endl;
\par \hich\af2\dbch\af31505\loch\f2         AODVRERR *newRERR = createRERR(unreachableNeighbors\hich\af2\dbch\af31505\loch\f2 );
\par \hich\af2\dbch\af31505\loch\f2         sendAODVPacket(newRERR, IPv4Address::ALLONES_ADDRESS, 1, 0);
\par \hich\af2\dbch\af31505\loch\f2         rerrCount++;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     delete rerr;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 bool AODVRouting::handleOperationStage(LifecycleOperation *operation, int stage, IDoneCallback *doneCallback)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     Enter_Method_Silent();
\par \hich\af2\dbch\af31505\loch\f2     if (dynamic_cast<NodeStartOperation *>(operation)) \{
\par \hich\af2\dbch\af31505\loch\f2         if (stage == NodeStartOperation::STAGE_APPLICATION_LAYER) \{
\par \hich\af2\dbch\af31505\loch\f2             isOperational = true;
\par \hich\af2\dbch\af31505\loch\f2             rebootTime = simTime();
\par 
\par \hich\af2\dbch\af31505\loch\f2             if (useHelloMessages)
\par \hich\af2\dbch\af31505\loch\f2                 scheduleAt(simTime() + helloInterval - periodicJitter->doubleValue(), helloMsgTimer);
\par 
\par \hich\af2\dbch\af31505\loch\f2             scheduleAt(simTime() + 1, counterTimer);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else if (dynamic_cast<NodeShutdownOperation *>(operation)) \{
\par \hich\af2\dbch\af31505\loch\f2         if (stage \hich\af2\dbch\af31505\loch\f2 == NodeShutdownOperation::STAGE_APPLICATION_LAYER) \{
\par \hich\af2\dbch\af31505\loch\f2             isOperational = false;
\par \hich\af2\dbch\af31505\loch\f2             clearState();
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else if (dynamic_cast<NodeCrashOperation *>(operation)) \{
\par \hich\af2\dbch\af31505\loch\f2         if (stage == NodeCrashOperation::STAGE_CRASH) \{
\par \hich\af2\dbch\af31505\loch\f2         \hich\af2\dbch\af31505\loch\f2     isOperational = false;
\par \hich\af2\dbch\af31505\loch\f2             clearState();
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         throw cRuntimeError("Unsupported lifecycle operation '%s'", operation->getClassName());
\par 
\par \hich\af2\dbch\af31505\loch\f2     return true;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::clearState()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     rerrCount = rreqCount = rreqId = sequenceNum = 0;
\par \hich\af2\dbch\af31505\loch\f2     addressToRreqRetries.clear();
\par \hich\af2\dbch\af31505\loch\f2     for (std::map<IPv4Address, WaitForRREP *>::iterator it = waitForRREPTimers.begin(); it != waitForRREPTimers.end(); ++it)
\par \hich\af2\dbch\af31505\loch\f2         cancelAndDelete(it->second);
\par 
\par \hich\af2\dbch\af31505\loch\f2     /\hich\af2\dbch\af31505\loch\f2 / FIXME: Drop the queued datagrams.
\par \hich\af2\dbch\af31505\loch\f2     //for (std::multimap<IPv4Address, IPv4Datagram *>::iterator it = targetAddressToDelayedPackets.begin(); it != targetAddressToDelayedPackets.end(); it++)
\par \hich\af2\dbch\af31505\loch\f2     //    networkProtocol->dropQueuedDatagram(const_cast<const \hich\af2\dbch\af31505\loch\f2 IPv4Datagram *>(it->second));
\par 
\par \hich\af2\dbch\af31505\loch\f2     targetAddressToDelayedPackets.clear();
\par 
\par \hich\af2\dbch\af31505\loch\f2     waitForRREPTimers.clear();
\par \hich\af2\dbch\af31505\loch\f2     rreqsArrivalTime.clear();
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (useHelloMessages)
\par \hich\af2\dbch\af31505\loch\f2         cancelEvent(helloMsgTimer);
\par 
\par \hich\af2\dbch\af31505\loch\f2     cancelEvent(expungeTimer);
\par \hich\af2\dbch\af31505\loch\f2     cancelEvent(counterTi\hich\af2\dbch\af31505\loch\f2 mer);
\par \hich\af2\dbch\af31505\loch\f2     cancelEvent(blacklistTimer);
\par \hich\af2\dbch\af31505\loch\f2     cancelEvent(rrepAckTimer);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleWaitForRREP(WaitForRREP *rrepTimer)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "We didn't get any Route Reply within RREP timeout" << endl;
\par \hich\af2\dbch\af31505\loch\f2     IPv4Address destAddr = rrepTimer->getDestAddr();
\par 
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(addressToRreqRetries.find(destAddr) != addressToRreqRetries.end());
\par \hich\af2\dbch\af31505\loch\f2     if (addressToRreqRetries[destAddr] == rreqRetries) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "Re-discovery attempts for node " << destAddr <\hich\af2\dbch\af31505\loch\f2 < " reached RREQ_RETRIES= " << rreqRetries << " limit. Stop sending RREQ." << endl;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     AODVRREQ *rreq = createRREQ(destAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // the node MAY try again to discover a route by broadcasting another
\par \hich\af2\dbch\af31505\loch\f2     // RREQ, up to a maximum of\hich\af2\dbch\af31505\loch\f2  RREQ_RETRIES times at the maximum TTL value.
\par \hich\af2\dbch\af31505\loch\f2     if (rrepTimer->getLastTTL() == netDiameter) // netDiameter is the maximum TTL value
\par \hich\af2\dbch\af31505\loch\f2         addressToRreqRetries[destAddr]++;
\par 
\par \hich\af2\dbch\af31505\loch\f2     sendRREQ(rreq, IPv4Address::ALLONES_ADDRESS, 0);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::forwa\hich\af2\dbch\af31505\loch\f2 rdRREP(AODVRREP *rrep, const IPv4Address& destAddr, unsigned int timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Forwarding the Route Reply to the node " << rrep->getOriginatorAddr() << " which originated the Route Request" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // RFC 5148:
\par \hich\af2\dbch\af31505\loch\f2     // When a node forw\hich\af2\dbch\af31505\loch\f2 ards a message, it SHOULD be jittered by delaying it
\par \hich\af2\dbch\af31505\loch\f2     // by a random duration.  This delay SHOULD be generated uniformly in an
\par \hich\af2\dbch\af31505\loch\f2     // interval between zero and MAXJITTER.
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rrep, destAddr, 100, jitterPar->doubleValue());
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::forwardRREQ(AODVRREQ *rreq, unsigned int timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Forwarding the Route Request message with TTL= " << timeToLive << endl;
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rreq, IPv4Address::ALLONES_ADDRESS, timeToLive, jitterPar->doubleValue());
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::completeRouteDiscovery(const IPv4Address& target)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_DETAIL << "Completing route discovery, originator " << getSelfIPAddress() << ", target " << target << endl;
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(hasOngoingRouteDiscovery(target));
\par 
\par \hich\af2\dbch\af31505\loch\f2     std::multimap<IPv4\hich\af2\dbch\af31505\loch\f2 Address, IPv4Datagram *>::iterator lt = targetAddressToDelayedPackets.lower_bound(target);
\par \hich\af2\dbch\af31505\loch\f2     std::multimap<IPv4Address, IPv4Datagram *>::iterator ut = targetAddressToDelayedPackets.upper_bound(target);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // reinject the delayed datagrams
\par \hich\af2\dbch\af31505\loch\f2     for (std:\hich\af2\dbch\af31505\loch\f2 :multimap<IPv4Address, IPv4Datagram *>::iterator it = lt; it != ut; it++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Datagram *datagram = it->second;
\par \hich\af2\dbch\af31505\loch\f2         EV_DETAIL << "Sending queued datagram: source " << datagram->getSrcAddress() << ", destination " << datagram->getDestAddress() \hich\af2\dbch\af31505\loch\f2 << endl;
\par \hich\af2\dbch\af31505\loch\f2         networkProtocol->reinjectQueuedDatagram(const_cast<const IPv4Datagram *>(datagram));
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // clear the multimap
\par \hich\af2\dbch\af31505\loch\f2     targetAddressToDelayedPackets.erase(lt, ut);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // we have a route for the destination, thus we must cancel the WaitForRREPTimer events
\par \hich\af2\dbch\af31505\loch\f2     std::map<IPv4Address, WaitForRREP *>::iterator waitRREPIter = waitForRREPTimers.find(target);
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(waitRREPIter != waitForRREPTimers.end());
\par \hich\af2\dbch\af31505\loch\f2     cancelAnd\hich\af2\dbch\af31505\loch\f2 Delete(waitRREPIter->second);
\par \hich\af2\dbch\af31505\loch\f2     waitForRREPTimers.erase(waitRREPIter);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendGRREP(AODVRREP *grrep, const IPv4Address& destAddr, unsigned int timeToLive)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Sending gratuitous Route Reply to " << destAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     I\hich\af2\dbch\af31505\loch\f2 Pv4Route *destRoute = routingTable->findBestMatchingRoute(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& nextHop = destRoute->getGateway();
\par 
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(grrep, nextHop, timeToLive, 0);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRREP *AODVRouting::createHelloMessage()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // called a Hello messag\hich\af2\dbch\af31505\loch\f2 e, with the RREP
\par \hich\af2\dbch\af31505\loch\f2     // message fields set as follows:
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //    Destination IP IPv4Address         The node's IP address.
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //    Destination Sequence Number    The node's latest sequence number.
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //    Hop Count                 \hich\af2\dbch\af31505\loch\f2      0
\par \hich\af2\dbch\af31505\loch\f2     //
\par \hich\af2\dbch\af31505\loch\f2     //    Lifetime                       ALLOWED_HELLO_LOSS *HELLO_INTERVAL
\par 
\par \hich\af2\dbch\af31505\loch\f2     AODVRREP *helloMessage = new AODVRREP("AODV-HelloMsg");
\par \hich\af2\dbch\af31505\loch\f2     helloMessage->setPacketType(RREP);
\par \hich\af2\dbch\af31505\loch\f2     helloMessage->setDestAddr(getSelfIPAddress());
\par \hich\af2\dbch\af31505\loch\f2     helloMessage->setDestSeqNum(sequenceNum);
\par \hich\af2\dbch\af31505\loch\f2     helloMessage->setHopCount(0);
\par \hich\af2\dbch\af31505\loch\f2     helloMessage->setLifeTime(allowedHelloLoss * helloInterval);
\par 
\par \hich\af2\dbch\af31505\loch\f2     return helloMessage;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendHelloMessagesIfNeeded()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(useHelloMessages);
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // Every HELLO_INTERVAL milliseconds, the node checks whether it has
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // sent a broadcast (e.g., a RREQ or an appropriate layer 2 message)
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // within the last HELLO_INTERVAL.  If it has not, it MAY broadcast
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // a RREP with TTL = 1
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // A node \hich\af2\dbch\af31505\loch\f2 SHOULD only use hel}{\rtlch\fcs1 \af2 \ltrch\fcs0 
\f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2 lo messages if it is\hich\af2\dbch\af31505\loch\f2  part of an }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 active route.
\par \hich\af2\dbch\af31505\loch\f2     bool hasActiveRoute = false;
\par 
\par \hich\af2\dbch\af31505\loch\f2     }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 for (int i = 0; i < routingTable->getNumRoutes(); i++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->getRoute(i);
\par \hich\af2\dbch\af31505\loch\f2         if (route->getSource() == t\hich\af2\dbch\af31505\loch\f2 his) \{
\par \hich\af2\dbch\af31505\loch\f2             AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2             if (routeData->isActive()) \{
\par \hich\af2\dbch\af31505\loch\f2                 hasActiveRoute = true;
\par \hich\af2\dbch\af31505\loch\f2                 break;
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (hasActiveRoute && (lastBroadcastTime == 0 || simTime() - lastBroadcastTime > helloInterval)) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_INFO << "It is hello time, broadcasting Hello Messages with TTL=1" << endl;
\par \hich\af2\dbch\af31505\loch\f2         AODVRREP *helloMessage = createHelloMessage();
\par \hich\af2\dbch\af31505\loch\f2         sen\hich\af2\dbch\af31505\loch\f2 dAODVPacket(helloMessage, IPv4Address::ALLONES_ADDRESS, 1, 0);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     scheduleAt(simTime() + helloInterval - periodicJitter->doubleValue(), helloMsgTimer);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleHelloMessage(AODVRREP *helloMessage)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& helloOr\hich\af2\dbch\af31505\loch\f2 iginatorAddr = helloMessage->getDestAddr();
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *routeHelloOriginator = routingTable->findBestMatchingRoute(helloOriginatorAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Whenever a node receives a Hello message from a neighbor, the node
\par \hich\af2\dbch\af31505\loch\f2     // SHOULD make sure that it has an ac\hich\af2\dbch\af31505\loch\f2 tive route to the neighbor, and
\par \hich\af2\dbch\af31505\loch\f2     // create one if necessary.  If a route already exists, then the
\par \hich\af2\dbch\af31505\loch\f2     // Lifetime for the route should be increased, if necessary, to be at
\par \hich\af2\dbch\af31505\loch\f2     // least ALLOWED_HELLO_LOSS * HELLO_INTERVAL.  The route to the
\par \hich\af2\dbch\af31505\loch\f2     // neighb\hich\af2\dbch\af31505\loch\f2 or, if it exists, MUST subsequently contain the latest
\par \hich\af2\dbch\af31505\loch\f2     // Destination Sequence Number from the Hello message.  The current node
\par \hich\af2\dbch\af31505\loch\f2     // can now begin using this route to forward data packets.  Routes that
\par \hich\af2\dbch\af31505\loch\f2     // are created by hello messages and not used by any other active routes
\par \hich\af2\dbch\af31505\loch\f2     // will have empty precursor lists and would not trigger a RERR message
\par \hich\af2\dbch\af31505\loch\f2     // if the neighbor moves away and a neighbor timeout occurs.
\par 
\par \hich\af2\dbch\af31505\loch\f2     unsigned int latestDestSeqNum = h\hich\af2\dbch\af31505\loch\f2 elloMessage->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2     simtime_t newLifeTime = simTime() + allowedHelloLoss * helloInterval;
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (!routeHelloOriginator || routeHelloOriginator->getSource() != this)
\par \hich\af2\dbch\af31505\loch\f2         createRoute(helloOriginatorAddr, helloOriginatorAddr, 1, true, late\hich\af2\dbch\af31505\loch\f2 stDestSeqNum, true, newLifeTime);
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = check_and_cast<AODVRouteData *>(routeHelloOriginator->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         simtime_t lifeTime = routeData->getLifeTime();
\par \hich\af2\dbch\af31505\loch\f2         updateRoutingTable(routeHelloOriginator\hich\af2\dbch\af31505\loch\f2 , helloOriginatorAddr, 1, true, latestDestSeqNum, true, std::max(lifeTime, newLifeTime));
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // TODO: This feature has not implemented yet.
\par \hich\af2\dbch\af31505\loch\f2     // A node MAY determine connectivity by listening for packets from its
\par \hich\af2\dbch\af31505\loch\f2     // set of neighbors.  If, wit\hich\af2\dbch\af31505\loch\f2 hin the past DELETE_PERIOD, it has received
\par \hich\af2\dbch\af31505\loch\f2     // a Hello message from a neighbor, and then for that neighbor does not
\par \hich\af2\dbch\af31505\loch\f2     // receive any packets (Hello messages or otherwise) for more than
\par \hich\af2\dbch\af31505\loch\f2     // ALLOWED_HELLO_LOSS * HELLO_INTERVAL milliseconds, the node\hich\af2\dbch\af31505\loch\f2  SHOULD
\par \hich\af2\dbch\af31505\loch\f2     // assume that the link to this neighbor is currently lost.  When this
\par \hich\af2\dbch\af31505\loch\f2     // happens, the node SHOULD proceed as in Section 6.11.
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::expungeRoutes()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     for (int i = 0; i < routingTable->getNumRoutes(); i++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->getRoute(i);
\par \hich\af2\dbch\af31505\loch\f2         if (route->getSource() == this) \{
\par \hich\af2\dbch\af31505\loch\f2             AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2             ASSERT(routeData != NULL);
\par \hich\af2\dbch\af31505\loch\f2             if (routeDa\hich\af2\dbch\af31505\loch\f2 ta->getLifeTime() <= simTime()) \{
\par \hich\af2\dbch\af31505\loch\f2                 if (routeData->isActive()) \{
\par \hich\af2\dbch\af31505\loch\f2                     EV_DETAIL << "Route to " << route->getDestination() << " expired and set to inactive. It will be deleted after DELETE_PERIOD time" << endl;
\par \hich\af2\dbch\af31505\loch\f2                  \hich\af2\dbch\af31505\loch\f2    // An expired routing table entry SHOULD NOT be expunged before
\par \hich\af2\dbch\af31505\loch\f2                     // (current_time + DELETE_PERIOD) (see section 6.11).  Otherwise, the
\par \hich\af2\dbch\af31505\loch\f2                     // soft state corresponding to the route (e.g., last known hop count)
\par \hich\af2\dbch\af31505\loch\f2          \hich\af2\dbch\af31505\loch\f2            // will be lost.
\par \hich\af2\dbch\af31505\loch\f2                     routeData->setIsActive(false);
\par \hich\af2\dbch\af31505\loch\f2                     routeData->setLifeTime(simTime() + deletePeriod);
\par \hich\af2\dbch\af31505\loch\f2                 \}
\par \hich\af2\dbch\af31505\loch\f2                 else \{
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2   }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // Any routing table entry waiting for a RREP \hich\af2\dbch\af31505\loch\f2 
SHOULD NOT be expunged
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid7492685 \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2  }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 // before (current_time + 2 * NET_TRAVERSAL_TIME).
\par \hich\af2\dbch\af31505\loch\f2                     if (hasOngoingRouteDiscovery(route->getDestination())) \{
\par \hich\af2\dbch\af31505\loch\f2                         }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\cf17\insrsid8979034 \hich\af2\dbch\af31505\loch\f2 EV_DETAIL << "Route to " << route->getDestination() << " expi\hich\af2\dbch\af31505\loch\f2 
red and is inactive, but we are waiting for a RREP to this destination, so we extend its lifetime with 2 * NET_TRAVERSAL_TIME" << endl;
\par \hich\af2\dbch\af31505\loch\f2                         routeData->setLifeTime(simTime() + 2 * netTraversalTime);
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 \hich\af2\dbch\af31505\loch\f2                     \}
\par \hich\af2\dbch\af31505\loch\f2                 \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2                         EV_DETAIL << "Route to " << route->getDestination() << " expired and is inactive and we are not expecting any RREP to this destination, so we delete this route" << endl;
\par \hich\af2\dbch\af31505\loch\f2                         routingTable->deleteRoute(r\hich\af2\dbch\af31505\loch\f2 oute);
\par \hich\af2\dbch\af31505\loch\f2                     \}
\par \hich\af2\dbch\af31505\loch\f2                 \}
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     scheduleExpungeRoutes();
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::scheduleExpungeRoutes()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     simtime_t nextExpungeTime = SimTime::getMaxTime();
\par \hich\af2\dbch\af31505\loch\f2     for (int i = 0; i < routingTable->getNumRoutes(); i++) \{
\par \hich\af2\dbch\af31505\loch\f2         IPv4Route *route = routingTable->getRoute(i);
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (route->getSource() == this) \{
\par \hich\af2\dbch\af31505\loch\f2             AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2             ASSERT(routeData != NULL);
\par 
\par \hich\af2\dbch\af31505\loch\f2             if (routeData->getLifeTime() < nextExpungeTime)
\par \hich\af2\dbch\af31505\loch\f2                 nextExpungeTime = routeData->getLifeTime();
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     if (nextExpungeTime == SimTime::getMaxTime()) \{
\par \hich\af2\dbch\af31505\loch\f2         if (expungeTimer->is\hich\af2\dbch\af31505\loch\f2 Scheduled())
\par \hich\af2\dbch\af31505\loch\f2             cancelEvent(expungeTimer);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else \{
\par \hich\af2\dbch\af31505\loch\f2         if (!expungeTimer->isScheduled())
\par \hich\af2\dbch\af31505\loch\f2             scheduleAt(nextExpungeTime, expungeTimer);
\par \hich\af2\dbch\af31505\loch\f2         else \{
\par \hich\af2\dbch\af31505\loch\f2             if (expungeTimer->getArrivalTime() != nextExpungeTime) \{
\par \hich\af2\dbch\af31505\loch\f2                 cancelEvent(expungeTimer);
\par \hich\af2\dbch\af31505\loch\f2                 scheduleAt(nextExpungeTime, expungeTimer);
\par \hich\af2\dbch\af31505\loch\f2             \}
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 INetfilter::IHook::Result AODVRouting::datagramForwardHook(IPv4Datagram *datagram, const InterfaceEntry *inputInterfaceEn\hich\af2\dbch\af31505\loch\f2 
try, const InterfaceEntry *& outputInterfaceEntry, IPv4Address& nextHopAddress)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // TODO: Implement: Actions After Reboot
\par \hich\af2\dbch\af31505\loch\f2     // If the node receives a data packet for some other destination, it SHOULD
\par \hich\af2\dbch\af31505\loch\f2     // broadcast a RERR as described in subsectio\hich\af2\dbch\af31505\loch\f2 n 6.11 and MUST reset the waiting
\par \hich\af2\dbch\af31505\loch\f2     // timer to expire after current time plus DELETE_PERIOD.
\par 
\par \hich\af2\dbch\af31505\loch\f2     Enter_Method("datagramForwardHook");
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& destAddr = datagram->getDestAddress();
\par \hich\af2\dbch\af31505\loch\f2     const IPv4Address& sourceAddr = datagram->getSrcAddr\hich\af2\dbch\af31505\loch\f2 ess();
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *ipSource = routingTable->findBestMatchingRoute(sourceAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (destAddr.isLimitedBroadcastAddress() || routingTable->isLocalAddress(destAddr) || destAddr.isMulticast()) \{
\par \hich\af2\dbch\af31505\loch\f2         if (routingTable->isLocalAddress(destAddr) && ipS\hich\af2\dbch\af31505\loch\f2 ource && ipSource->getSource() == this)
\par \hich\af2\dbch\af31505\loch\f2             updateValidRouteLifeTime(ipSource->getGateway(), simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2         return ACCEPT;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     // TODO: IMPLEMENT: check if the datagram is a data packet or we take control packets a\hich\af2\dbch\af31505\loch\f2 s data packets
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *routeDest = routingTable->findBestMatchingRoute(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *routeDestData = routeDest ? dynamic_cast<AODVRouteData *>(routeDest->getProtocolData()) : NULL;
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Each time a route is us\hich\af2\dbch\af31505\loch\f2 ed to forward a data packet, its Active Route
\par \hich\af2\dbch\af31505\loch\f2     // Lifetime field of the source, destination and the next hop on the
\par \hich\af2\dbch\af31505\loch\f2     // path to the destination is updated to be no less than the current
\par \hich\af2\dbch\af31505\loch\f2     // time plus ACTIVE_ROUTE_TIMEOUT
\par 
\par \hich\af2\dbch\af31505\loch\f2     updateValidRouteLifeT\hich\af2\dbch\af31505\loch\f2 ime(sourceAddr, simTime() + activeRouteTimeout);
\par \hich\af2\dbch\af31505\loch\f2     updateValidRouteLifeTime(destAddr, simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (routeDest && routeDest->getSource() == this)
\par \hich\af2\dbch\af31505\loch\f2         updateValidRouteLifeTime(routeDest->getGateway(), simTime() + activeRoute\hich\af2\dbch\af31505\loch\f2 Timeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2     // Since the route between each originator and destination pair is expected
\par \hich\af2\dbch\af31505\loch\f2     // to be symmetric, the Active Route Lifetime for the previous hop, along the
\par \hich\af2\dbch\af31505\loch\f2     // reverse path back to the IP source, is also updated to be no less than the
\par \hich\af2\dbch\af31505\loch\f2  \hich\af2\dbch\af31505\loch\f2    // current time plus ACTIVE_ROUTE_TIMEOUT.
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (ipSource && ipSource->getSource() == this)
\par \hich\af2\dbch\af31505\loch\f2         updateValidRouteLifeTime(ipSource->getGateway(), simTime() + activeRouteTimeout);
\par 
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "We can't forward datagram because we have no active\hich\af2\dbch\af31505\loch\f2  route for " << destAddr << endl;
\par \hich\af2\dbch\af31505\loch\f2     if (routeDest && routeDestData && !routeDestData->isActive()) \{    // exists but is not active
\par \hich\af2\dbch\af31505\loch\f2         // A node initiates processing for a RERR message in three situations:
\par \hich\af2\dbch\af31505\loch\f2         // (ii)      if it gets a data packe\hich\af2\dbch\af31505\loch\f2 t destined to a node for which it
\par \hich\af2\dbch\af31505\loch\f2         //           does not have an active route and is not repairing (if
\par \hich\af2\dbch\af31505\loch\f2         //           using local repair)
\par 
\par \hich\af2\dbch\af31505\loch\f2         // TODO: check if it is not repairing (if using local repair)
\par 
\par \hich\af2\dbch\af31505\loch\f2         // 1. The destination sequence number of this routing entry, if it
\par \hich\af2\dbch\af31505\loch\f2         // exists and is valid, is incremented for cases (i) and (ii) above,
\par \hich\af2\dbch\af31505\loch\f2         // and copied from the incoming RERR in case (iii) above.
\par 
\par \hich\af2\dbch\af31505\loch\f2         if (routeDestData->hasValidDe\hich\af2\dbch\af31505\loch\f2 stNum())
\par \hich\af2\dbch\af31505\loch\f2             routeDestData->setDestSeqNum(routeDestData->getDestSeqNum() + 1);
\par 
\par \hich\af2\dbch\af31505\loch\f2         // 2. The entry is invalidated by marking the route entry as invalid <- it is invalid
\par 
\par \hich\af2\dbch\af31505\loch\f2         // 3. The Lifetime field is updated to current time plus DELETE_P\hich\af2\dbch\af31505\loch\f2 ERIOD.
\par \hich\af2\dbch\af31505\loch\f2         //    Before this time, the entry SHOULD NOT be deleted.
\par \hich\af2\dbch\af31505\loch\f2         routeDestData->setLifeTime(simTime() + deletePeriod);
\par 
\par \hich\af2\dbch\af31505\loch\f2         sendRERRWhenNoRouteToForward(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     else if (!routeDest || routeDest->getSource() != this) // doesn\hich\af2\dbch\af31505\loch\f2 't exist at all
\par \hich\af2\dbch\af31505\loch\f2         sendRERRWhenNoRouteToForward(destAddr);
\par 
\par \hich\af2\dbch\af31505\loch\f2     return ACCEPT;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendRERRWhenNoRouteToForward(const IPv4Address& unreachableAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     if (rerrCount >= rerrRatelimit) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_WARN << "A node should not generate more than RERR_RATELIMIT RERR messages per second. Canceling sending RERR" << endl;
\par \hich\af2\dbch\af31505\loch\f2         return;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     std::vector<UnreachableNode> unreachableNodes;
\par \hich\af2\dbch\af31505\loch\f2     UnreachableNode node;
\par \hich\af2\dbch\af31505\loch\f2     node.addr = unreachabl\hich\af2\dbch\af31505\loch\f2 eAddr;
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *unreachableRoute = routingTable->findBestMatchingRoute(unreachableAddr);
\par \hich\af2\dbch\af31505\loch\f2     AODVRouteData *unreachableRouteData = unreachableRoute ? dynamic_cast<AODVRouteData *>(unreachableRoute->getProtocolData()) : NULL;
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (unreachableRout\hich\af2\dbch\af31505\loch\f2 eData && unreachableRouteData->hasValidDestNum())
\par \hich\af2\dbch\af31505\loch\f2         node.seqNum = unreachableRouteData->getDestSeqNum();
\par \hich\af2\dbch\af31505\loch\f2     else
\par \hich\af2\dbch\af31505\loch\f2         node.seqNum = 0;
\par 
\par \hich\af2\dbch\af31505\loch\f2     unreachableNodes.push_back(node);
\par \hich\af2\dbch\af31505\loch\f2     AODVRERR *rerr = createRERR(unreachableNodes);
\par 
\par \hich\af2\dbch\af31505\loch\f2     rerrCount++;
\par \hich\af2\dbch\af31505\loch\f2    \hich\af2\dbch\af31505\loch\f2  EV_INFO << "Broadcasting Route Error message with TTL=1" << endl;
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rerr, IPv4Address::ALLONES_ADDRESS, 1, jitterPar->doubleValue());    // TODO: unicast if there exists a route to the source
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::cancelRouteDiscovery(cons\hich\af2\dbch\af31505\loch\f2 t IPv4Address& destAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(hasOngoingRouteDiscovery(destAddr));
\par \hich\af2\dbch\af31505\loch\f2     std::multimap<IPv4Address, IPv4Datagram *>::iterator lt = targetAddressToDelayedPackets.lower_bound(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     std::multimap<IPv4Address, IPv4Datagram *>::iterator ut = targ\hich\af2\dbch\af31505\loch\f2 etAddressToDelayedPackets.upper_bound(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     for (std::multimap<IPv4Address, IPv4Datagram *>::iterator it = lt; it != ut; it++)
\par \hich\af2\dbch\af31505\loch\f2         networkProtocol->dropQueuedDatagram(const_cast<const IPv4Datagram *>(it->second));
\par 
\par \hich\af2\dbch\af31505\loch\f2     targetAddressToDelayedPackets.erase(lt, ut);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 bool AODVRouting::updateValidRouteLifeTime(const IPv4Address& destAddr, simtime_t lifetime)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *route = routingTable->findBestMatchingRoute(destAddr);
\par \hich\af2\dbch\af31505\loch\f2     if (route && route->getSource() == t\hich\af2\dbch\af31505\loch\f2 his) \{
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getProtocolData());
\par \hich\af2\dbch\af31505\loch\f2         if (routeData->isActive()) \{
\par \hich\af2\dbch\af31505\loch\f2             simtime_t newLifeTime = std::max(routeData->getLifeTime(), lifetime);
\par \hich\af2\dbch\af31505\loch\f2             EV_DETAIL << "Updating "\hich\af2\dbch\af31505\loch\f2  << route << " lifetime to " << newLifeTime << endl;
\par \hich\af2\dbch\af31505\loch\f2             routeData->setLifeTime(newLifeTime);
\par \hich\af2\dbch\af31505\loch\f2             return true;
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \hich\af2\dbch\af31505\loch\f2     return false;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRREPACK *AODVRouting::createRREPACK()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     AODVRREPACK *rrepACK = new AODVRREPACK("AODV\hich\af2\dbch\af31505\loch\f2 -RREPACK");
\par \hich\af2\dbch\af31505\loch\f2     rrepACK->setPacketType(RREPACK);
\par \hich\af2\dbch\af31505\loch\f2     return rrepACK;
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::sendRREPACK(AODVRREPACK *rrepACK, const IPv4Address& destAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "Sending Route Reply ACK to " << destAddr << endl;
\par \hich\af2\dbch\af31505\loch\f2     sendAODVPacket(rrepACK, destAddr, 100, 0);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleRREPACK(AODVRREPACK *rrepACK, const IPv4Address& neighborAddr)
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // Note that the RREP-ACK packet does not contain any information about
\par \hich\af2\dbch\af31505\loch\f2     // which RREP it is acknowledging.  T\hich\af2\dbch\af31505\loch\f2 he time at which the RREP-ACK is
\par \hich\af2\dbch\af31505\loch\f2     // received will likely come just after the time when the RREP was sent
\par \hich\af2\dbch\af31505\loch\f2     // with the 'A' bit.
\par \hich\af2\dbch\af31505\loch\f2     ASSERT(rrepAckTimer->isScheduled());
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "RREP-ACK arrived from " << neighborAddr << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     IPv4Route *\hich\af2\dbch\af31505\loch\f2 route = routingTable->findBestMatchingRoute(neighborAddr);
\par \hich\af2\dbch\af31505\loch\f2     if (route && route->getSource() == this) \{
\par \hich\af2\dbch\af31505\loch\f2         EV_DETAIL << "Marking route " << route << " as active" << endl;
\par \hich\af2\dbch\af31505\loch\f2         AODVRouteData *routeData = check_and_cast<AODVRouteData *>(route->getP\hich\af2\dbch\af31505\loch\f2 rotocolData());
\par \hich\af2\dbch\af31505\loch\f2         routeData->setIsActive(true);
\par \hich\af2\dbch\af31505\loch\f2         cancelEvent(rrepAckTimer);
\par \hich\af2\dbch\af31505\loch\f2     \}
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleRREPACKTimer()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     // when a node detects that its transmission of a RREP message has failed,
\par \hich\af2\dbch\af31505\loch\f2     // it remembers the next-hop of th\hich\af2\dbch\af31505\loch\f2 e failed RREP in a "blacklist" set.
\par 
\par \hich\af2\dbch\af31505\loch\f2     EV_INFO << "RREP-ACK didn't arrived within timeout. Adding " << failedNextHop << " to the blacklist" << endl;
\par 
\par \hich\af2\dbch\af31505\loch\f2     blacklist[failedNextHop] = simTime() + blacklistTimeout;    // lifetime
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (!blacklistTimer->isScheduled())
\par \hich\af2\dbch\af31505\loch\f2         scheduleAt(simTime() + blacklistTimeout, blacklistTimer);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 void AODVRouting::handleBlackListTimer()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     simtime_t nextTime = SimTime::getMaxTime();
\par 
\par \hich\af2\dbch\af31505\loch\f2     for (std::map<IPv4Address, simtime_t>::iterator it \hich\af2\dbch\af31505\loch\f2 = blacklist.begin(); it != blacklist.end(); ) \{
\par \hich\af2\dbch\af31505\loch\f2         std::map<IPv4Address, simtime_t>::iterator current = it++;
\par 
\par \hich\af2\dbch\af31505\loch\f2         // Nodes are removed from the blacklist set after a BLACKLIST_TIMEOUT period
\par \hich\af2\dbch\af31505\loch\f2         if (current->second <= simTime()) \{
\par \hich\af2\dbch\af31505\loch\f2            \hich\af2\dbch\af31505\loch\f2  EV_DETAIL << "Blacklist lifetime has expired for " << current->first << " removing it from the blacklisted addresses" << endl;
\par \hich\af2\dbch\af31505\loch\f2             blacklist.erase(current);
\par \hich\af2\dbch\af31505\loch\f2         \}
\par \hich\af2\dbch\af31505\loch\f2         else if (nextTime > current->second)
\par \hich\af2\dbch\af31505\loch\f2             nextTime = current->sec\hich\af2\dbch\af31505\loch\f2 ond;
\par \hich\af2\dbch\af31505\loch\f2     \}
\par 
\par \hich\af2\dbch\af31505\loch\f2     if (nextTime != SimTime::getMaxTime())
\par \hich\af2\dbch\af31505\loch\f2         scheduleAt(nextTime, blacklistTimer);
\par \}
\par 
\par \hich\af2\dbch\af31505\loch\f2 AODVRouting::~AODVRouting()
\par \{
\par \hich\af2\dbch\af31505\loch\f2     clearState();
\par \hich\af2\dbch\af31505\loch\f2     delete helloMsgTimer;
\par \hich\af2\dbch\af31505\loch\f2     delete expungeTimer;
\par \hich\af2\dbch\af31505\loch\f2     delete counterTimer;
\par \hich\af2\dbch\af31505\loch\f2     delete rrepAckTimer;
\par \hich\af2\dbch\af31505\loch\f2     delete blacklistTimer;
\par 
\par \hich\af2\dbch\af31505\loch\f2     nb = NotificationBoardAccess().getIfExists(this);
\par \hich\af2\dbch\af31505\loch\f2     if (nb)
\par \hich\af2\dbch\af31505\loch\f2         nb->unsubscribe(this, NF_LINK_BREAK);
\par \}
\par 
\par }{\rtlch\fcs1 \af2 \ltrch\fcs0 \f2\insrsid8979034 
\par }{\*\themedata 504b030414000600080000002100e9de0fbfff0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb4ec3301045f748fc83e52d4a
9cb2400825e982c78ec7a27cc0c8992416c9d8b2a755fbf74cd25442a820166c2cd933f79e3be372bd1f07b5c3989ca74aaff2422b24eb1b475da5df374fd9ad
5689811a183c61a50f98f4babebc2837878049899a52a57be670674cb23d8e90721f90a4d2fa3802cb35762680fd800ecd7551dc18eb899138e3c943d7e503b6
b01d583deee5f99824e290b4ba3f364eac4a430883b3c092d4eca8f946c916422ecab927f52ea42b89a1cd59c254f919b0e85e6535d135a8de20f20b8c12c3b0
0c895fcf6720192de6bf3b9e89ecdbd6596cbcdd8eb28e7c365ecc4ec1ff1460f53fe813d3cc7f5b7f020000ffff0300504b030414000600080000002100a5d6
a7e7c0000000360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4f
c7060abb0884a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b6309512
0f88d94fbc52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462
a1a82fe353bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f746865
6d652f7468656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b
4b0d592c9c070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b
4757e8d3f729e245eb2b260a0238fd010000ffff0300504b03041400060008000000210030dd4329a8060000a41b0000160000007468656d652f7468656d652f
7468656d65312e786d6cec594f6fdb3614bf0fd87720746f6327761a07758ad8b19b2d4d1bc46e871e698996d850a240d2497d1bdae38001c3ba618715d86d87
615b8116d8a5fb34d93a6c1dd0afb0475292c5585e9236d88aad3e2412f9e3fbff1e1fa9abd7eec70c1d1221294fda5efd72cd4324f1794093b0eddd1ef62fad
79482a9c0498f184b4bd2991deb58df7dfbb8ad755446282607d22d771db8b944ad79796a40fc3585ee62949606ecc458c15bc8a702910f808e8c66c69b9565b
5d8a314d3c94e018c8de1a8fa94fd05093f43672e23d06af89927ac06762a049136785c10607758d9053d965021d62d6f6804fc08f86e4bef210c352c144dbab
999fb7b4717509af678b985ab0b6b4ae6f7ed9ba6c4170b06c788a705430adf71bad2b5b057d03606a1ed7ebf5babd7a41cf00b0ef83a6569632cd467faddec9
699640f6719e76b7d6ac355c7c89feca9cccad4ea7d36c65b258a206641f1b73f8b5da6a6373d9c11b90c537e7f08dce66b7bbeae00dc8e257e7f0fd2badd586
8b37a088d1e4600ead1ddaef67d40bc898b3ed4af81ac0d76a197c86826828a24bb318f3442d8ab518dfe3a20f000d6458d104a9694ac6d88728eee2782428d6
0cf03ac1a5193be4cbb921cd0b495fd054b5bd0f530c1931a3f7eaf9f7af9e3f45c70f9e1d3ff8e9f8e1c3e3073f5a42ceaa6d9c84e5552fbffdeccfc71fa33f
9e7ef3f2d117d57859c6fffac327bffcfc793510d26726ce8b2f9ffcf6ecc98baf3efdfdbb4715f04d814765f890c644a29be408edf3181433567125272371be
15c308d3f28acd249438c19a4b05fd9e8a1cf4cd296699771c393ac4b5e01d01e5a30a787d72cf1178108989a2159c77a2d801ee72ce3a5c545a6147f32a9979
3849c26ae66252c6ed637c58c5bb8b13c7bfbd490a75330f4b47f16e441c31f7184e140e494214d273fc80900aedee52ead87597fa824b3e56e82e451d4c2b4d
32a423279a668bb6690c7e9956e90cfe766cb37b077538abd27a8b1cba48c80acc2a841f12e698f13a9e281c57911ce298950d7e03aba84ac8c154f8655c4f2a
f074481847bd804859b5e696007d4b4edfc150b12addbecba6b18b148a1e54d1bc81392f23b7f84137c2715a851dd0242a633f900710a218ed715505dfe56e86
e877f0034e16bafb0e258ebb4faf06b769e888340b103d331115bebc4eb813bf83291b63624a0d1475a756c734f9bbc2cd28546ecbe1e20a3794ca175f3fae90
fb6d2dd99bb07b55e5ccf68942bd0877b23c77b908e8db5f9db7f024d9239010f35bd4bbe2fcae387bfff9e2bc289f2fbe24cfaa301468dd8bd846dbb4ddf1c2
ae7b4c191ba8292337a469bc25ec3d411f06f53a73e224c5292c8de0516732307070a1c0660d125c7d44553488700a4d7bddd3444299910e254ab984c3a219ae
a4adf1d0f82b7bd46cea4388ad1c12ab5d1ed8e1153d9c9f350a3246aad01c6873462b9ac05999ad5cc988826eafc3acae853a33b7ba11cd1445875ba1b236b1
399483c90bd560b0b0263435085a21b0f22a9cf9356b38ec6046026d77eba3dc2dc60b17e92219e180643ed27acffba86e9c94c7ca9c225a0f1b0cfae0788ad5
4adc5a9aec1b703b8b93caec1a0bd8e5de7b132fe5113cf312503b998e2c2927274bd051db6b35979b1ef271daf6c6704e86c73805af4bdd476216c26593af84
0dfb5393d964f9cc9bad5c313709ea70f561ed3ea7b053075221d51696910d0d339585004b34272bff7213cc7a510a5454a3b349b1b206c1f0af490176745d4b
c663e2abb2b34b23da76f6352ba57ca2881844c1111ab189d8c7e07e1daaa04f40255c77988aa05fe06e4e5bdb4cb9c5394bbaf28d98c1d971ccd20867e556a7
689ec9166e0a522183792b8907ba55ca6e943bbf2a26e52f48957218ffcf54d1fb09dc3eac04da033e5c0d0b8c74a6b43d2e54c4a10aa511f5fb021a07533b20
5ae07e17a621a8e082dafc17e450ffb739676998b48643a4daa7211214f623150942f6a02c99e83b85583ddbbb2c4996113211551257a656ec1139246ca86be0
aadedb3d1441a89b6a929501833b197fee7b9641a3503739e57c732a59b1f7da1cf8a73b1f9bcca0945b874d4393dbbf10b1680f66bbaa5d6f96e77b6f59113d
316bb31a795600b3d256d0cad2fe354538e7566b2bd69cc6cbcd5c38f0e2bcc63058344429dc2121fd07f63f2a7c66bf76e80d75c8f7a1b622f878a18941d840
545fb28d07d205d20e8ea071b283369834296bdaac75d256cb37eb0bee740bbe278cad253b8bbfcf69eca23973d939b97891c6ce2cecd8da8e2d343578f6648a
c2d0383fc818c798cf64e52f597c740f1cbd05df0c264c49134cf09d4a60e8a107260f20f92d47b374e32f000000ffff0300504b030414000600080000002100
0dd1909fb60000001b010000270000007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f7
8277086f6fd3ba109126dd88d0add40384e4350d363f2451eced0dae2c082e8761be9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89
d93b64b060828e6f37ed1567914b284d262452282e3198720e274a939cd08a54f980ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd500
1996509affb3fd381a89672f1f165dfe514173d9850528a2c6cce0239baa4c04ca5bbabac4df000000ffff0300504b01022d0014000600080000002100e9de0f
bfff0000001c0200001300000000000000000000000000000000005b436f6e74656e745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6
a7e7c0000000360100000b00000000000000000000000000300100005f72656c732f2e72656c73504b01022d00140006000800000021006b799616830000008a
0000001c00000000000000000000000000190200007468656d652f7468656d652f7468656d654d616e616765722e786d6c504b01022d00140006000800000021
0030dd4329a8060000a41b00001600000000000000000000000000d60200007468656d652f7468656d652f7468656d65312e786d6c504b01022d001400060008
00000021000dd1909fb60000001b0100002700000000000000000000000000b20900007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d010000ad0a00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax267\lsdlockeddef0\lsdsemihiddendef1\lsdunhideuseddef1\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;
\lsdpriority39 \lsdlocked0 toc 1;\lsdpriority39 \lsdlocked0 toc 2;\lsdpriority39 \lsdlocked0 toc 3;\lsdpriority39 \lsdlocked0 toc 4;\lsdpriority39 \lsdlocked0 toc 5;\lsdpriority39 \lsdlocked0 toc 6;\lsdpriority39 \lsdlocked0 toc 7;
\lsdpriority39 \lsdlocked0 toc 8;\lsdpriority39 \lsdlocked0 toc 9;\lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdpriority1 \lsdlocked0 Default Paragraph Font;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority59 \lsdlocked0 Table Grid;\lsdunhideused0 \lsdlocked0 Placeholder Text;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;\lsdunhideused0 \lsdlocked0 Revision;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdpriority37 \lsdlocked0 Bibliography;\lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e362e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffff0c6ad98892f1d411a65f0040963251e50000000000000000000000002028
744e51c4d801feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}